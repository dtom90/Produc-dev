{"version":3,"sources":["webpack:///./node_modules/clamp/index.js","webpack:///./node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js","webpack:///./node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js"],"names":["clamp","value","min","max","module","exports","interaction","modes","visibleElements","event","filterElements","intersect","options","getNearestItem","axis","getElements","mode","nearest","inRangeByAxis","element","inRange","x","y","getPointByAxis","center","filter","minDistance","Number","POSITIVE_INFINITY","reduce","nearestItems","getCenterPoint","evenPoint","distance","push","sort","a","b","_index","slice","rotated","point","angle","cos","Math","sin","cx","cy","isOlderPart","act","req","length","EPSILON","from","to","inLimit","limit","hitSize","start","end","clampAll","obj","key","Object","keys","inPointRange","radius","pow","inBoxRange","x2","y2","borderWidth","hitTolerance","inRangeX","inRangeY","inLabelRange","rect","rotation","rotPoint","getElementCenterPoint","useFinalPosition","centerX","centerY","getProps","requireVersion","pkg","ver","strict","parts","split","i","parseInt","Error","isPercentString","s","endsWith","toPercent","parseFloat","toPositivePercent","boxAppering","width","height","defaultInitAnimation","box","properties","doughnutLabel","ellipse","label","line","polygon","getRelativePosition","size","position","getSize","positivePercent","calculateTextAlignment","textAlign","measureLabelRectangle","labelSize","xAdjust","yAdjust","padding","hasPadding","positionObj","toPosition","calculateLabelPosition$1","defaultValue","shouldFit","fitRatio","autoFit","toFonts","optFont","font","fonts","map","f","floor","lineHeight","isBoundToPoint","xValue","yValue","adjust","initAnimationProperties","chart","initAnim","init","applyDefault","execCallback","loadHooks","hooks","hooksContainer","activated","forEach","hook","type","result","widthCache","Map","notRadius","isNaN","fontsKey","prev","item","string","isImageOrCanvas","content","toString","translate","ctx","rotate","setBorderStyle","lineCap","borderCapStyle","setLineDash","borderDash","lineDashOffset","borderDashOffset","lineJoin","borderJoinStyle","lineWidth","strokeStyle","borderColor","setShadowStyle","shadowColor","backgroundShadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","measureLabelSize","strokeWidth","textStrokeWidth","lines","mapKey","join","_measureText","has","set","calculateLabelSize","get","drawBox","save","stroke","fillStyle","backgroundColor","beginPath","w","h","borderRadius","closePath","fill","borderShadowColor","restore","drawLabel","globalAlpha","getOpacity","opacity","style","drawImage","labels","optColor","color","colors","textBaseline","setTextStrokeStyle","applyLabelDecoration","applyLabelContent","miterLimit","textStrokeColor","drawPoint","pointStyle","rad","drawPointStyle","xOffset","yOffset","cornerRadius","arc","moveTo","lineTo","SQRT1_2","count","text","measureText","lhs","l","lh","strokeText","c","fillText","elementValue","positions","drawCallout","pointX","pointY","callout","calloutPosition","display","resolveCalloutPosition","isPointInRange","separatorStart","separatorEnd","getCalloutSeparatorCoord","sideStart","sideEnd","getCalloutSideCoord","margin","rotatedPoint","getCalloutSeparatorAdjust","side","getCalloutSideAdjust","includes","resolveCalloutAutoPosition","xPoints","yPoints","index","limitedLineScale","xScaleID","startProp","endProp","yScaleID","scaleValue","scale","fallback","parse","getPixelForValue","retrieveScaleID","scales","scaleID","charAt","axes","values","id","getDimensionByScale","reverse","getChartPoint","chartArea","xScale","yScale","left","top","resolveBoxProperties","right","bottom","xDim","getChartDimensionByScale","xMin","xMax","yDim","yMin","yMax","resolvePointProperties","adjustCenterX","adjustCenterY","getChartCircle","resolveLineProperties","area","resolveFullLineProperties","resolveLimitedLineProperties","resolveBoxAndLabelProperties","initProperties","elements","optionScope","resolveLabelElementProperties$1","NaN","endValue","isHorizontal","scaleId","dim","calculateX","calculatePosition","calculateY","boxOpts","labelOpts","padStart","padEnd","availableSize","moveHooks","eventHooks","concat","updateListeners","state","listened","listeners","moveListened","annotations","scope","click","handleEvent","handleMoveEvents","handleClickEvents","previous","hovered","context","changed","dispatchMoveEvents","checkElements","indexOf","dispatchEvent","handler","$context","elementHooks","updateHooks","hooked","invokeHook","callbackHook","adjustScaleRange","range","getScaleLimits","changeScaleLimit","handleTickRangeOptions","verifyScaleOptions","annotation","verifyScaleIDs","suggestedLimit","scaleLimitDefined","scaleOptions","verifyProperties","console","warn","prop","scaleIDOption","limits","NEGATIVE_INFINITY","updateLimits","props","raw","BoxAnnotation","mouseX","mouseY","this","defaults","undefined","drawTime","family","weight","z","defaultRoutes","descriptors","_fallback","DoughnutLabelAnnotation","drawBackground","_fitRatio","meta","getDatasetMeta","controllerMeta","getControllerMeta","getFitRatio","boxSize","getSortedVisibleDatasetMetas","controller","isControllerVisible","data","innerRadius","circumference","autoHide","hidden","getDataVisibility","offsetX","offsetY","square","space","spacing","_radius","_counterclockwise","angles","getAngles","_centerX","_centerY","hypo","sqrt","yk2","r2","delta","_startAngle","_endAngle","LabelAnnotation","visible","_visible","getLabelSize","hBorderWidth","pointInLine","p1","p2","t","interpolateX","abs","interpolateY","sqr","v","rangeLimit","coordInCurve","cp","pointInCurve","coordAngleInCurve","angleInCurve","atan2","LineAnnotation","path","mx","currentDevicePixelRatio","my","isPointInStroke","isOnLabel","epsilon","intersects","inAxisRange","curve","drawCurve","startOpts","endOpts","startAdjust","endAdjust","getArrowHeads","drawArrowHead","inside","isLineInArea","limitLineToArea","getControlPoint","labelProperties","resolveLabelElementProperties","arrowHeadsDefaults","limitPointToArea","x1","y1","dx","dy","lenSq","xx","yy","textSize","calculateLabelPosition","calculateAutoRotation","sizes","rotatedSize","calculateT","pt","xCoordinateSizes","yCoordinateSizes","adjustLabelCoordinate","spaceAround","calculateTAdjust","lineSize","lineW","lineH","r","coordinate","labelSizes","halfSize","arrowStartOpts","arrowHeads","arrowEndOpts","getLineAdjust","arrowOpts","offset","arrowOffsetX","controlPoint","drawArrowHeadOnCurve","startAngle","endAngle","ps","pe","Path2D","quadraticCurveTo","assign","EllipseAnnotation","pointInEllipse","p","xRadius","yRadius","cosAngle","sinAngle","PointAnnotation","PolygonAnnotation","pointIsInPolygon","axisPoints","bY","bX","first","el","sides","elProps","buildPointElement","points","isInside","A","B","annotationTypes","describe","directUpdater","update","hooks$1","resolve","optDefs","resolveObj","isIndexable","resolveType","updateElements","animations","resolveAnimations","resyncElements","annotationOptions","getOrCreateElement","resolver","setContext","getContext","resolveElementProperties","skip","toSkip","updateSubElements","resolveAnnotationOptions","animOpts","mainElement","subElements","definition","subElement","subResolver","override","elementClass","defs","create","add","splice","Array","version","chartStates","isNotDoughnutLabel","register","unregister","args","_args","draw","clip","delete","numbers","common","_indexable","_scriptable","_allKeys","opts","additionalOptionScopes","caller","drawableElements","getDrawableElements","drawElement","main","sub","devicePixelRatio","window","screen","deviceXDPI","logicalXDPI","utils","toTextLines","inputs","input","pop","unshift","apply","isArray","items","ilen","bound","arrayDiff","a0","a1","j","updates","rasterize","round","orient","origin","x0","y0","ln","aligned","vx","vy","align","PI","R_INSIDE","R_LEFT","R_RIGHT","R_BOTTOM","R_TOP","region","res","clipped","segment","r0","r1","compute$1","config","anchor","positioners","outerRadius","rx","ry","bar","sx","sy","horizontal","base","boundingRects","model","th","tw","tx","ty","frame","getScaleOrigin","datasetIndex","vScale","xCenter","yCenter","pixel","getBasePixel","getPositioner","drawRoundedRect","HALF_PI","drawFrame","bgColor","textGeometry","drawTextLine","cfg","shadow","stroked","filled","drawText","strokeColor","textShadowBlur","textShadowColor","Label","me","_config","_model","_rects","_ctx","_el","prototype","_modelize","positioner","rects","dataset","formatter","geometry","MIN_INTEGER","MIN_SAFE_INTEGER","MAX_INTEGER","MAX_SAFE_INTEGER","projected","dp","toAxis","p0","HitBox","_rotation","_rect","coordinates","vs","collide","collider","s0","s1","$layout","_box","compute","proxy","Proxy","h0","_hidable","h1","contains","other","pr0","pr1","_points","layout","prepare","datasets","jlen","_set","_idx","sa","sb","dirty","lookup","klen","k","EXPANDO_KEY","DEFAULT_KEY","configure","datalabels","configs","_key","target","fn","callback$1","groups","$groups","_dirty","enter","leave","expando","_listeners","_labels","_hovered","handlers","plugin","beforeInit","_actives","beforeUpdate","_listened","_datasets","afterDatasetUpdate","isDatasetVisible","active","dataIndex","merger","source","afterUpdate","afterDatasetsDraw","beforeEvent","afterEvent","actives","getActiveElements","render"],"mappings":"2GAEA,SAASA,EAAMC,EAAOC,EAAKC,GACzB,OAAOD,EAAMC,EACRF,EAAQC,EAAMA,EAAMD,EAAQE,EAAMA,EAAMF,EACxCA,EAAQE,EAAMA,EAAMF,EAAQC,EAAMA,EAAMD,EAL/CG,EAAOC,QAAUL,G,kCCAjB;;;;;;;AAcA,MAAMM,EAAc,CAClBC,MAAO,CAOL,MAAMC,EAAiBC,GACrB,OAAOC,EAAeF,EAAiBC,EAAO,CAACE,WAAW,KAU5D,QAAQH,EAAiBC,EAAOG,GAC9B,OAAOC,EAAeL,EAAiBC,EAAOG,IAShD,EAAEJ,EAAiBC,EAAOG,GACxB,OAAOF,EAAeF,EAAiBC,EAAO,CAACE,UAAWC,EAAQD,UAAWG,KAAM,OAUrF,EAAEN,EAAiBC,EAAOG,GACxB,OAAOF,EAAeF,EAAiBC,EAAO,CAACE,UAAWC,EAAQD,UAAWG,KAAM,SAYzF,SAASC,EAAYP,EAAiBC,EAAOG,GAC3C,MAAMI,EAAOV,EAAYC,MAAMK,EAAQI,OAASV,EAAYC,MAAMU,QAClE,OAAOD,EAAKR,EAAiBC,EAAOG,GAGtC,SAASM,EAAcC,EAASV,EAAOK,GACrC,MAAa,MAATA,GAAyB,MAATA,EACXK,EAAQC,QAAQX,EAAMY,EAAGZ,EAAMa,EAAG,KAAK,IAASH,EAAQC,QAAQX,EAAMY,EAAGZ,EAAMa,EAAG,KAAK,GAEzFH,EAAQC,QAAQX,EAAMY,EAAGZ,EAAMa,EAAGR,GAAM,GAGjD,SAASS,EAAed,EAAOe,EAAQV,GACrC,MAAa,MAATA,EACK,CAACO,EAAGZ,EAAMY,EAAGC,EAAGE,EAAOF,GACZ,MAATR,EACF,CAACO,EAAGG,EAAOH,EAAGC,EAAGb,EAAMa,GAEzBE,EAGT,SAASd,EAAeF,EAAiBC,EAAOG,GAC9C,OAAOJ,EAAgBiB,OAAQN,GAAYP,EAAQD,UAAYQ,EAAQC,QAAQX,EAAMY,EAAGZ,EAAMa,GAAKJ,EAAcC,EAASV,EAAOG,EAAQE,OAG3I,SAASD,EAAeL,EAAiBC,EAAOG,GAC9C,IAAIc,EAAcC,OAAOC,kBAEzB,OAAOlB,EAAeF,EAAiBC,EAAOG,GAC3CiB,OAAO,CAACC,EAAcX,KACrB,MAAMK,EAASL,EAAQY,iBACjBC,EAAYT,EAAed,EAAOe,EAAQZ,EAAQE,MAClDmB,EAAW,eAAsBxB,EAAOuB,GAS9C,OARIC,EAAWP,GACbI,EAAe,CAACX,GAChBO,EAAcO,GACLA,IAAaP,GAEtBI,EAAaI,KAAKf,GAGbW,GACN,IACFK,KAAK,CAACC,EAAGC,IAAMD,EAAEE,OAASD,EAAEC,QAC5BC,MAAM,EAAG,GAcd,SAASC,EAAQC,EAAOjB,EAAQkB,GAC9B,MAAMC,EAAMC,KAAKD,IAAID,GACfG,EAAMD,KAAKC,IAAIH,GACfI,EAAKtB,EAAOH,EACZ0B,EAAKvB,EAAOF,EAElB,MAAO,CACLD,EAAGyB,EAAKH,GAAOF,EAAMpB,EAAIyB,GAAMD,GAAOJ,EAAMnB,EAAIyB,GAChDzB,EAAGyB,EAAKF,GAAOJ,EAAMpB,EAAIyB,GAAMH,GAAOF,EAAMnB,EAAIyB,IAIpD,MAAMC,EAAc,CAACC,EAAKC,IAAQA,EAAMD,GAAQA,EAAIE,OAASD,EAAIC,QAAUF,EAAIV,MAAM,EAAGW,EAAIC,UAAYD,EAQlGE,EAAU,KACVpD,EAAQ,CAACqB,EAAGgC,EAAMC,IAAOV,KAAK1C,IAAIoD,EAAIV,KAAKzC,IAAIkD,EAAMhC,IAOrDkC,EAAU,CAACC,EAAOC,IAAYD,EAAMvD,OAASuD,EAAME,MAAQD,GAAWD,EAAMvD,OAASuD,EAAMG,IAAMF,EAQvG,SAASG,EAASC,EAAKR,EAAMC,GAC3B,IAAK,MAAMQ,KAAOC,OAAOC,KAAKH,GAC5BA,EAAIC,GAAO9D,EAAM6D,EAAIC,GAAMT,EAAMC,GAEnC,OAAOO,EAUT,SAASI,EAAaxB,EAAOjB,EAAQ0C,EAAQT,GAC3C,SAAKhB,IAAUjB,GAAU0C,GAAU,IAG3BtB,KAAKuB,IAAI1B,EAAMpB,EAAIG,EAAOH,EAAG,GAAKuB,KAAKuB,IAAI1B,EAAMnB,EAAIE,EAAOF,EAAG,IAAOsB,KAAKuB,IAAID,EAAST,EAAS,GAU3G,SAASW,EAAW3B,GAAO,EAACpB,EAAC,EAAEC,EAAC,GAAE+C,EAAE,GAAEC,GAAKxD,GAAM,YAACyD,EAAW,aAAEC,IAC7D,MAAMf,GAAWc,EAAcC,GAAgB,EACzCC,EAAWhC,EAAMpB,GAAKA,EAAIoC,EAAUL,GAAWX,EAAMpB,GAAKgD,EAAKZ,EAAUL,EACzEsB,EAAWjC,EAAMnB,GAAKA,EAAImC,EAAUL,GAAWX,EAAMnB,GAAKgD,EAAKb,EAAUL,EAC/E,MAAa,MAATtC,EACK2D,GACW,MAAT3D,GAGJ2D,IAFEC,EAYX,SAASC,EAAalC,GAAO,KAACmC,EAAI,OAAEpD,GAASV,GAAM,SAAC+D,EAAQ,YAAEN,EAAW,aAAEC,IACzE,MAAMM,EAAWtC,EAAQC,EAAOjB,EAAQ,gBAAWqD,IACnD,OAAOT,EAAWU,EAAUF,EAAM9D,EAAM,CAACyD,cAAaC,iBAQxD,SAASO,EAAsB5D,EAAS6D,GACtC,MAAM,QAACC,EAAO,QAAEC,GAAW/D,EAAQgE,SAAS,CAAC,UAAW,WAAYH,GACpE,MAAO,CAAC3D,EAAG4D,EAAS3D,EAAG4D,GAUzB,SAASE,EAAeC,EAAKnF,EAAKoF,EAAKC,GAAS,GAC9C,MAAMC,EAAQF,EAAIG,MAAM,KACxB,IAAIC,EAAI,EACR,IAAK,MAAMxC,KAAOhD,EAAIuF,MAAM,KAAM,CAChC,MAAMxC,EAAMuC,EAAME,KAClB,GAAIC,SAASzC,EAAK,IAAMyC,SAAS1C,EAAK,IACpC,MAEF,GAAID,EAAYC,EAAKC,GAAM,CACzB,GAAIqC,EACF,MAAM,IAAIK,MAAM,GAAGP,MAAQC,wBAA0BpF,2BAErD,OAAO,GAIb,OAAO,EAGT,MAAM2F,EAAmBC,GAAmB,kBAANA,GAAkBA,EAAEC,SAAS,KAC7DC,EAAaF,GAAMG,WAAWH,GAAK,IACnCI,EAAqBJ,GAAM9F,EAAMgG,EAAUF,GAAI,EAAG,GAElDK,EAAc,CAAC9E,EAAGC,KAAM,CAAED,IAAGC,IAAG+C,GAAIhD,EAAGiD,GAAIhD,EAAG8E,MAAO,EAAGC,OAAQ,IAChEC,EAAuB,CAC3BC,IAAMC,GAAeL,EAAYK,EAAWvB,QAASuB,EAAWtB,SAChEuB,cAAgBD,GAAeL,EAAYK,EAAWvB,QAASuB,EAAWtB,SAC1EwB,QAAUF,IAAe,CAAEvB,QAASuB,EAAWvB,QAASC,QAASsB,EAAWvB,QAASf,OAAQ,EAAGkC,MAAO,EAAGC,OAAQ,IAClHM,MAAQH,GAAeL,EAAYK,EAAWvB,QAASuB,EAAWtB,SAClE0B,KAAOJ,GAAeL,EAAYK,EAAWnF,EAAGmF,EAAWlF,GAC3DmB,MAAQ+D,IAAe,CAAEvB,QAASuB,EAAWvB,QAASC,QAASsB,EAAWtB,QAAShB,OAAQ,EAAGkC,MAAO,EAAGC,OAAQ,IAChHQ,QAAUL,GAAeL,EAAYK,EAAWvB,QAASuB,EAAWtB,UAmBtE,SAAS4B,EAAoBC,EAAMC,GACjC,MAAiB,UAAbA,EACK,EAEQ,QAAbA,EACKD,EAELlB,EAAgBmB,GACXd,EAAkBc,GAAYD,EAEhCA,EAAO,EAShB,SAASE,EAAQF,EAAM9G,EAAOiH,GAAkB,GAC9C,MAAqB,kBAAVjH,EACFA,EACE4F,EAAgB5F,IACjBiH,EAAkBhB,EAAkBjG,GAAS+F,EAAU/F,IAAU8G,EAEpEA,EAQT,SAASI,EAAuBJ,EAAMnG,GACpC,MAAM,EAACS,EAAC,MAAE+E,GAASW,EACbK,EAAYxG,EAAQwG,UAC1B,MAAkB,WAAdA,EACK/F,EAAI+E,EAAQ,EACI,QAAdgB,GAAqC,UAAdA,EACzB/F,EAAI+E,EAEN/E,EAUT,SAASgG,EAAsB5E,EAAO6E,GAAW,YAAC/C,EAAW,SAAEyC,EAAQ,QAAEO,EAAO,QAAEC,GAAUC,GAC1F,MAAMC,EAAa,eAASD,GACtBrB,EAAQkB,EAAUlB,OAASsB,EAAaD,EAAQrB,MAAQ,GAAK7B,EAC7D8B,EAASiB,EAAUjB,QAAUqB,EAAaD,EAAQpB,OAAS,GAAK9B,EAChEoD,EAAcC,EAAWZ,GACzB3F,EAAIwG,EAAyBpF,EAAMpB,EAAG+E,EAAOmB,EAASI,EAAYtG,GAClEC,EAAIuG,EAAyBpF,EAAMnB,EAAG+E,EAAQmB,EAASG,EAAYrG,GAEzE,MAAO,CACLD,IACAC,IACA+C,GAAIhD,EAAI+E,EACR9B,GAAIhD,EAAI+E,EACRD,QACAC,SACApB,QAAS5D,EAAI+E,EAAQ,EACrBlB,QAAS5D,EAAI+E,EAAS,GAS1B,SAASuB,EAAW3H,EAAO6H,EAAe,UACxC,OAAI,eAAS7H,GACJ,CACLoB,EAAG,eAAepB,EAAMoB,EAAGyG,GAC3BxG,EAAG,eAAerB,EAAMqB,EAAGwG,KAG/B7H,EAAQ,eAAeA,EAAO6H,GACvB,CACLzG,EAAGpB,EACHqB,EAAGrB,IASP,MAAM8H,EAAY,CAACnH,EAASoH,IAAapH,GAAWA,EAAQqH,SAAWD,EAAW,EAOlF,SAASE,EAAQtH,EAASoH,GACxB,MAAMG,EAAUvH,EAAQwH,KAClBC,EAAQ,eAAQF,GAAWA,EAAU,CAACA,GAC5C,OAAIJ,EAAUnH,EAASoH,GACdK,EAAMC,KAAI,SAASC,GACxB,MAAMH,EAAO,eAAOG,GAGpB,OAFAH,EAAKrB,KAAOnE,KAAK4F,MAAMD,EAAExB,KAAOiB,GAChCI,EAAKK,WAAaF,EAAEE,WACb,eAAOL,MAGXC,EAAMC,IAAIC,GAAK,eAAOA,IAO/B,SAASG,EAAe9H,GACtB,OAAOA,IAAY,eAAQA,EAAQ+H,SAAW,eAAQ/H,EAAQgI,SAGhE,SAASf,EAAyBnE,EAAOqD,EAAM8B,EAAS,EAAG7B,GACzD,OAAOtD,EAAQoD,EAAoBC,EAAMC,GAAY6B,EASvD,SAASC,EAAwBC,EAAOvC,EAAY5F,GAClD,MAAMoI,EAAWpI,EAAQqI,KACzB,GAAKD,EAEE,OAAiB,IAAbA,EACFE,EAAa1C,EAAY5F,GAE3BuI,EAAaJ,EAAOvC,EAAY5F,GASzC,SAASwI,EAAUxI,EAASyI,EAAOC,GACjC,IAAIC,GAAY,EAShB,OARAF,EAAMG,QAAQC,IACR,eAAW7I,EAAQ6I,KACrBF,GAAY,EACZD,EAAeG,GAAQ7I,EAAQ6I,IACtB,eAAQH,EAAeG,YACzBH,EAAeG,KAGnBF,EAGT,SAASL,EAAa1C,EAAY5F,GAChC,MAAM8I,EAAO9I,EAAQ8I,MAAQ,OAC7B,OAAOpD,EAAqBoD,GAAMlD,GAGpC,SAAS2C,EAAaJ,EAAOvC,EAAY5F,GACvC,MAAM+I,EAAS,eAAS/I,EAAQqI,KAAM,CAAC,CAACF,QAAOvC,aAAY5F,aAC3D,OAAe,IAAX+I,EACKT,EAAa1C,EAAY5F,GACvB,eAAS+I,GACXA,OADF,EAKT,MAAMC,EAAa,IAAIC,IACjBC,EAAa5F,GAAW6F,MAAM7F,IAAWA,GAAU,EACnD8F,EAAY3B,GAAUA,EAAMxG,QAAO,SAASoI,EAAMC,GAEtD,OADAD,GAAQC,EAAKC,OACNF,IACN,IAcH,SAASG,EAAgBC,GACvB,GAAIA,GAA8B,kBAAZA,EAAsB,CAC1C,MAAMX,EAAOW,EAAQC,WACrB,MAAiB,8BAATZ,GAAiD,+BAATA,GAUpD,SAASa,EAAUC,GAAK,EAACnJ,EAAC,EAAEC,GAAIuD,GAC1BA,IACF2F,EAAID,UAAUlJ,EAAGC,GACjBkJ,EAAIC,OAAO,eAAU5F,IACrB2F,EAAID,WAAWlJ,GAAIC,IASvB,SAASoJ,EAAeF,EAAK5J,GAC3B,GAAIA,GAAWA,EAAQ2D,YAOrB,OANAiG,EAAIG,QAAU/J,EAAQgK,gBAAkB,OACxCJ,EAAIK,YAAYjK,EAAQkK,YACxBN,EAAIO,eAAiBnK,EAAQoK,iBAC7BR,EAAIS,SAAWrK,EAAQsK,iBAAmB,QAC1CV,EAAIW,UAAYvK,EAAQ2D,YACxBiG,EAAIY,YAAcxK,EAAQyK,aACnB,EAQX,SAASC,EAAed,EAAK5J,GAC3B4J,EAAIe,YAAc3K,EAAQ4K,sBAC1BhB,EAAIiB,WAAa7K,EAAQ6K,WACzBjB,EAAIkB,cAAgB9K,EAAQ8K,cAC5BlB,EAAImB,cAAgB/K,EAAQ+K,cAQ9B,SAASC,EAAiBpB,EAAK5J,GAC7B,MAAMyJ,EAAUzJ,EAAQyJ,QACxB,GAAID,EAAgBC,GAAU,CAC5B,MAAMtD,EAAO,CACXX,MAAOa,EAAQoD,EAAQjE,MAAOxF,EAAQwF,OACtCC,OAAQY,EAAQoD,EAAQhE,OAAQzF,EAAQyF,SAE1C,OAAOU,EAET,MAAMsB,EAAQH,EAAQtH,GAChBiL,EAAcjL,EAAQkL,gBACtBC,EAAQ,eAAQ1B,GAAWA,EAAU,CAACA,GACtC2B,EAASD,EAAME,OAASjC,EAAS3B,GAASwD,GAAerB,EAAI0B,aAAe,YAAc,IAIhG,OAHKtC,EAAWuC,IAAIH,IAClBpC,EAAWwC,IAAIJ,EAAQK,GAAmB7B,EAAKuB,EAAO1D,EAAOwD,IAExDjC,EAAW0C,IAAIN,GAQxB,SAASO,EAAQ/B,EAAK5F,EAAMhE,GAC1B,MAAM,EAACS,EAAC,EAAEC,EAAC,MAAE8E,EAAK,OAAEC,GAAUzB,EAC9B4F,EAAIgC,OACJlB,EAAed,EAAK5J,GACpB,MAAM6L,EAAS/B,EAAeF,EAAK5J,GACnC4J,EAAIkC,UAAY9L,EAAQ+L,gBACxBnC,EAAIoC,YACJ,eAAmBpC,EAAK,CACtBnJ,IAAGC,IAAGuL,EAAGzG,EAAO0G,EAAGzG,EACnBnC,OAAQN,EAAS,eAAchD,EAAQmM,cAAe,EAAGnK,KAAK1C,IAAIkG,EAAOC,GAAU,KAErFmE,EAAIwC,YACJxC,EAAIyC,OACAR,IACFjC,EAAIe,YAAc3K,EAAQsM,kBAC1B1C,EAAIiC,UAENjC,EAAI2C,UASN,SAASC,EAAU5C,EAAK5F,EAAMhE,EAASoH,GACrC,MAAMqC,EAAUzJ,EAAQyJ,QACxB,GAAID,EAAgBC,GAKlB,OAJAG,EAAIgC,OACJhC,EAAI6C,YAAcC,GAAW1M,EAAQ2M,QAASlD,EAAQmD,MAAMD,SAC5D/C,EAAIiD,UAAUpD,EAASzF,EAAKvD,EAAGuD,EAAKtD,EAAGsD,EAAKwB,MAAOxB,EAAKyB,aACxDmE,EAAI2C,UAGN,MAAMO,EAAS,eAAQrD,GAAWA,EAAU,CAACA,GACvChC,EAAQH,EAAQtH,EAASoH,GACzB2F,EAAW/M,EAAQgN,MACnBC,EAAS,eAAQF,GAAYA,EAAW,CAACA,GACzCtM,EAAI8F,EAAuBvC,EAAMhE,GACjCU,EAAIsD,EAAKtD,EAAIV,EAAQkL,gBAAkB,EAC7CtB,EAAIgC,OACJhC,EAAIsD,aAAe,SACnBtD,EAAIpD,UAAYxG,EAAQwG,UACpB2G,EAAmBvD,EAAK5J,IAC1BoN,GAAqBxD,EAAK,CAACnJ,IAAGC,KAAIoM,EAAQrF,GAE5C4F,GAAkBzD,EAAK,CAACnJ,IAAGC,KAAIoM,EAAQ,CAACrF,QAAOwF,WAC/CrD,EAAI2C,UAGN,SAASY,EAAmBvD,EAAK5J,GAC/B,GAAIA,EAAQkL,gBAAkB,EAM5B,OAJAtB,EAAIS,SAAW,QACfT,EAAI0D,WAAa,EACjB1D,EAAIW,UAAYvK,EAAQkL,gBACxBtB,EAAIY,YAAcxK,EAAQuN,iBACnB,EAUX,SAASC,EAAU5D,EAAKrJ,EAASE,EAAGC,GAClC,MAAM,OAAC4C,EAAM,QAAEtD,GAAWO,EACpBqM,EAAQ5M,EAAQyN,WAChBxJ,EAAWjE,EAAQiE,SACzB,IAAIyJ,GAAOzJ,GAAY,GAAK,OAE5B,GAAIuF,EAAgBoD,GAMlB,OALAhD,EAAIgC,OACJhC,EAAID,UAAUlJ,EAAGC,GACjBkJ,EAAIC,OAAO6D,GACX9D,EAAIiD,UAAUD,GAAQA,EAAMpH,MAAQ,GAAIoH,EAAMnH,OAAS,EAAGmH,EAAMpH,MAAOoH,EAAMnH,aAC7EmE,EAAI2C,UAGFrD,EAAU5F,IAGdqK,EAAe/D,EAAK,CAACnJ,IAAGC,IAAG4C,SAAQW,WAAU2I,QAAOc,QAGtD,SAASC,EAAe/D,GAAK,EAACnJ,EAAC,EAAEC,EAAC,OAAE4C,EAAM,SAAEW,EAAQ,MAAE2I,EAAK,IAAEc,IAC3D,IAAIE,EAASC,EAAS1H,EAAM2H,EAG5B,OAFAlE,EAAIoC,YAEIY,GAER,QACEhD,EAAImE,IAAItN,EAAGC,EAAG4C,EAAQ,EAAG,QACzBsG,EAAIwC,YACJ,MACF,IAAK,WACHxC,EAAIoE,OAAOvN,EAAIuB,KAAKC,IAAIyL,GAAOpK,EAAQ5C,EAAIsB,KAAKD,IAAI2L,GAAOpK,GAC3DoK,GAAO,OACP9D,EAAIqE,OAAOxN,EAAIuB,KAAKC,IAAIyL,GAAOpK,EAAQ5C,EAAIsB,KAAKD,IAAI2L,GAAOpK,GAC3DoK,GAAO,OACP9D,EAAIqE,OAAOxN,EAAIuB,KAAKC,IAAIyL,GAAOpK,EAAQ5C,EAAIsB,KAAKD,IAAI2L,GAAOpK,GAC3DsG,EAAIwC,YACJ,MACF,IAAK,cAQH0B,EAAwB,KAATxK,EACf6C,EAAO7C,EAASwK,EAChBF,EAAU5L,KAAKD,IAAI2L,EAAM,QAAcvH,EACvC0H,EAAU7L,KAAKC,IAAIyL,EAAM,QAAcvH,EACvCyD,EAAImE,IAAItN,EAAImN,EAASlN,EAAImN,EAASC,EAAcJ,EAAM,OAAIA,EAAM,QAChE9D,EAAImE,IAAItN,EAAIoN,EAASnN,EAAIkN,EAASE,EAAcJ,EAAM,OAASA,GAC/D9D,EAAImE,IAAItN,EAAImN,EAASlN,EAAImN,EAASC,EAAcJ,EAAKA,EAAM,QAC3D9D,EAAImE,IAAItN,EAAIoN,EAASnN,EAAIkN,EAASE,EAAcJ,EAAM,OAASA,EAAM,QACrE9D,EAAIwC,YACJ,MACF,IAAK,OACH,IAAKnI,EAAU,CACbkC,EAAOnE,KAAKkM,QAAU5K,EACtBsG,EAAI5F,KAAKvD,EAAI0F,EAAMzF,EAAIyF,EAAM,EAAIA,EAAM,EAAIA,GAC3C,MAEFuH,GAAO,OAET,IAAK,UACHE,EAAU5L,KAAKD,IAAI2L,GAAOpK,EAC1BuK,EAAU7L,KAAKC,IAAIyL,GAAOpK,EAC1BsG,EAAIoE,OAAOvN,EAAImN,EAASlN,EAAImN,GAC5BjE,EAAIqE,OAAOxN,EAAIoN,EAASnN,EAAIkN,GAC5BhE,EAAIqE,OAAOxN,EAAImN,EAASlN,EAAImN,GAC5BjE,EAAIqE,OAAOxN,EAAIoN,EAASnN,EAAIkN,GAC5BhE,EAAIwC,YACJ,MACF,IAAK,WACHsB,GAAO,OAET,IAAK,QACHE,EAAU5L,KAAKD,IAAI2L,GAAOpK,EAC1BuK,EAAU7L,KAAKC,IAAIyL,GAAOpK,EAC1BsG,EAAIoE,OAAOvN,EAAImN,EAASlN,EAAImN,GAC5BjE,EAAIqE,OAAOxN,EAAImN,EAASlN,EAAImN,GAC5BjE,EAAIoE,OAAOvN,EAAIoN,EAASnN,EAAIkN,GAC5BhE,EAAIqE,OAAOxN,EAAIoN,EAASnN,EAAIkN,GAC5B,MACF,IAAK,OACHA,EAAU5L,KAAKD,IAAI2L,GAAOpK,EAC1BuK,EAAU7L,KAAKC,IAAIyL,GAAOpK,EAC1BsG,EAAIoE,OAAOvN,EAAImN,EAASlN,EAAImN,GAC5BjE,EAAIqE,OAAOxN,EAAImN,EAASlN,EAAImN,GAC5BjE,EAAIoE,OAAOvN,EAAIoN,EAASnN,EAAIkN,GAC5BhE,EAAIqE,OAAOxN,EAAIoN,EAASnN,EAAIkN,GAC5BF,GAAO,OACPE,EAAU5L,KAAKD,IAAI2L,GAAOpK,EAC1BuK,EAAU7L,KAAKC,IAAIyL,GAAOpK,EAC1BsG,EAAIoE,OAAOvN,EAAImN,EAASlN,EAAImN,GAC5BjE,EAAIqE,OAAOxN,EAAImN,EAASlN,EAAImN,GAC5BjE,EAAIoE,OAAOvN,EAAIoN,EAASnN,EAAIkN,GAC5BhE,EAAIqE,OAAOxN,EAAIoN,EAASnN,EAAIkN,GAC5B,MACF,IAAK,OACHA,EAAU5L,KAAKD,IAAI2L,GAAOpK,EAC1BuK,EAAU7L,KAAKC,IAAIyL,GAAOpK,EAC1BsG,EAAIoE,OAAOvN,EAAImN,EAASlN,EAAImN,GAC5BjE,EAAIqE,OAAOxN,EAAImN,EAASlN,EAAImN,GAC5B,MACF,IAAK,OACHjE,EAAIoE,OAAOvN,EAAGC,GACdkJ,EAAIqE,OAAOxN,EAAIuB,KAAKD,IAAI2L,GAAOpK,EAAQ5C,EAAIsB,KAAKC,IAAIyL,GAAOpK,GAC3D,MAGFsG,EAAIyC,OAGN,SAASZ,GAAmB7B,EAAKuB,EAAO1D,EAAOwD,GAC7CrB,EAAIgC,OACJ,MAAMuC,EAAQhD,EAAM5I,OACpB,IAAIiD,EAAQ,EACRC,EAASwF,EACb,IAAK,IAAInG,EAAI,EAAGA,EAAIqJ,EAAOrJ,IAAK,CAC9B,MAAM0C,EAAOC,EAAMzF,KAAK1C,IAAIwF,EAAG2C,EAAMlF,OAAS,IAC9CqH,EAAIpC,KAAOA,EAAK+B,OAChB,MAAM6E,EAAOjD,EAAMrG,GACnBU,EAAQxD,KAAKzC,IAAIiG,EAAOoE,EAAIyE,YAAYD,GAAM5I,MAAQyF,GACtDxF,GAAU+B,EAAKK,WAGjB,OADA+B,EAAI2C,UACG,CAAC/G,QAAOC,UAGjB,SAAS2H,GAAqBxD,GAAK,EAACnJ,EAAC,EAAEC,GAAIoM,EAAQrF,GACjDmC,EAAIoC,YACJ,IAAIsC,EAAM,EACVxB,EAAOlE,SAAQ,SAAS2F,EAAGzJ,GACzB,MAAM6C,EAAIF,EAAMzF,KAAK1C,IAAIwF,EAAG2C,EAAMlF,OAAS,IACrCiM,EAAK7G,EAAEE,WACb+B,EAAIpC,KAAOG,EAAE4B,OACbK,EAAI6E,WAAWF,EAAG9N,EAAGC,EAAI8N,EAAK,EAAIF,GAClCA,GAAOE,KAET5E,EAAIiC,SAGN,SAASwB,GAAkBzD,GAAK,EAACnJ,EAAC,EAAEC,GAAIoM,GAAQ,MAACrF,EAAK,OAAEwF,IACtD,IAAIqB,EAAM,EACVxB,EAAOlE,SAAQ,SAAS2F,EAAGzJ,GACzB,MAAM4J,EAAIzB,EAAOjL,KAAK1C,IAAIwF,EAAGmI,EAAO1K,OAAS,IACvCoF,EAAIF,EAAMzF,KAAK1C,IAAIwF,EAAG2C,EAAMlF,OAAS,IACrCiM,EAAK7G,EAAEE,WACb+B,EAAIoC,YACJpC,EAAIpC,KAAOG,EAAE4B,OACbK,EAAIkC,UAAY4C,EAChB9E,EAAI+E,SAASJ,EAAG9N,EAAGC,EAAI8N,EAAK,EAAIF,GAChCA,GAAOE,EACP5E,EAAIyC,UAIR,SAASK,GAAWrN,EAAOuP,GACzB,MAAMjC,EAAU,eAAStN,GAASA,EAAQuP,EAC1C,OAAO,eAASjC,GAAWvN,EAAMuN,EAAS,EAAG,GAAK,EAGpD,MAAMkC,GAAY,CAAC,OAAQ,SAAU,MAAO,SAW5C,SAASC,GAAYlF,EAAKrJ,GACxB,MAAM,OAACwO,EAAM,OAAEC,EAAM,QAAEhP,GAAWO,EAC5B0O,EAAUjP,EAAQiP,QAClBC,EAAkBD,GAAWA,EAAQE,SAAWC,GAAuB7O,EAAS0O,GACtF,IAAKC,GAAmBG,GAAe9O,EAAS0O,EAASC,GACvD,OAGFtF,EAAIgC,OACJhC,EAAIoC,YACJ,MAAMH,EAAS/B,EAAeF,EAAKqF,GACnC,IAAKpD,EACH,OAAOjC,EAAI2C,UAEb,MAAM,eAAC+C,EAAc,aAAEC,GAAgBC,GAAyBjP,EAAS2O,IACnE,UAACO,EAAS,QAAEC,GAAWC,GAAoBpP,EAAS2O,EAAiBI,IACvEL,EAAQW,OAAS,GAA6B,IAAxB5P,EAAQ2D,eAChCiG,EAAIoE,OAAOsB,EAAe7O,EAAG6O,EAAe5O,GAC5CkJ,EAAIqE,OAAOsB,EAAa9O,EAAG8O,EAAa7O,IAE1CkJ,EAAIoE,OAAOyB,EAAUhP,EAAGgP,EAAU/O,GAClCkJ,EAAIqE,OAAOyB,EAAQjP,EAAGiP,EAAQhP,GAC9B,MAAMmP,EAAejO,EAAQ,CAACnB,EAAGsO,EAAQrO,EAAGsO,GAASzO,EAAQY,iBAAkB,gBAAWZ,EAAQ0D,WAClG2F,EAAIqE,OAAO4B,EAAapP,EAAGoP,EAAanP,GACxCkJ,EAAIiC,SACJjC,EAAI2C,UAGN,SAASiD,GAAyBjP,EAAS6F,GACzC,MAAM,EAAC3F,EAAC,EAAEC,EAAC,GAAE+C,EAAE,GAAEC,GAAMnD,EACjB0H,EAAS6H,GAA0BvP,EAAS6F,GAClD,IAAIkJ,EAAgBC,EASpB,MARiB,SAAbnJ,GAAoC,UAAbA,GACzBkJ,EAAiB,CAAC7O,EAAGA,EAAIwH,EAAQvH,KACjC6O,EAAe,CAAC9O,EAAG6O,EAAe7O,EAAGC,EAAGgD,KAGxC4L,EAAiB,CAAC7O,IAAGC,EAAGA,EAAIuH,GAC5BsH,EAAe,CAAC9O,EAAGgD,EAAI/C,EAAG4O,EAAe5O,IAEpC,CAAC4O,iBAAgBC,gBAG1B,SAASO,GAA0BvP,EAAS6F,GAC1C,MAAM,MAACZ,EAAK,OAAEC,EAAM,QAAEzF,GAAWO,EAC3B0H,EAASjI,EAAQiP,QAAQW,OAAS5P,EAAQ2D,YAAc,EAC9D,MAAiB,UAAbyC,EACKZ,EAAQyC,EACO,WAAb7B,EACFX,EAASwC,GAEVA,EAGV,SAAS0H,GAAoBpP,EAAS6F,EAAUkJ,GAC9C,MAAM,EAAC5O,EAAC,MAAE8E,EAAK,OAAEC,EAAM,QAAEzF,GAAWO,EAC9BuC,EAAQ9C,EAAQiP,QAAQnM,MACxBiN,EAAOC,GAAqB5J,EAAUpG,EAAQiP,SACpD,IAAIQ,EAAWC,EASf,MARiB,SAAbtJ,GAAoC,UAAbA,GACzBqJ,EAAY,CAAChP,EAAG6O,EAAe7O,EAAGC,EAAGA,EAAI2F,EAAQZ,EAAQ3C,IACzD4M,EAAU,CAACjP,EAAGgP,EAAUhP,EAAIsP,EAAMrP,EAAG+O,EAAU/O,KAG/C+O,EAAY,CAAChP,EAAG6O,EAAe7O,EAAI4F,EAAQb,EAAO1C,GAAQpC,EAAG4O,EAAe5O,GAC5EgP,EAAU,CAACjP,EAAGgP,EAAUhP,EAAGC,EAAG+O,EAAU/O,EAAIqP,IAEvC,CAACN,YAAWC,WAGrB,SAASM,GAAqB5J,EAAUpG,GACtC,MAAM+P,EAAO/P,EAAQ+P,KACrB,MAAiB,SAAb3J,GAAoC,QAAbA,GACjB2J,EAEHA,EAGT,SAASX,GAAuB7O,EAASP,GACvC,MAAMoG,EAAWpG,EAAQoG,SACzB,OAAIyI,GAAUoB,SAAS7J,GACdA,EAEF8J,GAA2B3P,EAASP,GAG7C,SAASkQ,GAA2B3P,EAASP,GAC3C,MAAM,EAACS,EAAC,EAAEC,EAAC,GAAE+C,EAAE,GAAEC,EAAE,MAAE8B,EAAK,OAAEC,EAAM,OAAEsJ,EAAM,OAAEC,EAAM,QAAE3K,EAAO,QAAEC,EAAO,SAAEL,GAAY1D,EAC5EK,EAAS,CAACH,EAAG4D,EAAS3D,EAAG4D,GACzBxB,EAAQ9C,EAAQ8C,MAChB6D,EAAUN,EAAQb,EAAO1C,GACzB8D,EAAUP,EAAQZ,EAAQ3C,GAC1BqN,EAAU,CAAC1P,EAAGA,EAAIkG,EAASlG,EAAIkG,EAASlD,GACxC2M,EAAU,CAAC1P,EAAIkG,EAASlD,EAAIhD,EAAGgD,GAC/BqF,EAAS,GACf,IAAK,IAAIsH,EAAQ,EAAGA,EAAQ,EAAGA,IAAS,CACtC,MAAMR,EAAejO,EAAQ,CAACnB,EAAG0P,EAAQE,GAAQ3P,EAAG0P,EAAQC,IAASzP,EAAQ,eAAUqD,IACvF8E,EAAOzH,KAAK,CACV8E,SAAUyI,GAAUwB,GACpBhP,SAAU,eAAsBwO,EAAc,CAACpP,EAAGsO,EAAQrO,EAAGsO,MAGjE,OAAOjG,EAAOxH,KAAK,CAACC,EAAGC,IAAMD,EAAEH,SAAWI,EAAEJ,UAAU,GAAG+E,SAG3D,SAASiJ,GAAe9O,EAAS0O,EAAS7I,GACxC,MAAM,OAAC2I,EAAM,OAAEC,GAAUzO,EACnBqP,EAASX,EAAQW,OACvB,IAAInP,EAAIsO,EACJrO,EAAIsO,EAUR,MATiB,SAAb5I,EACF3F,GAAKmP,EACiB,UAAbxJ,EACT3F,GAAKmP,EACiB,QAAbxJ,EACT1F,GAAKkP,EACiB,WAAbxJ,IACT1F,GAAKkP,GAEArP,EAAQC,QAAQC,EAAGC,GAG5B,MAAM4P,GAAmB,CACvBC,SAAU,CAACjR,IAAK,OAAQC,IAAK,OAAQuD,MAAO,OAAQC,IAAK,QAASyN,UAAW,IAAKC,QAAS,MAC3FC,SAAU,CAACpR,IAAK,OAAQC,IAAK,OAAQuD,MAAO,SAAUC,IAAK,MAAOyN,UAAW,IAAKC,QAAS,OAoB7F,SAASE,GAAWC,EAAOvR,EAAOwR,GAEhC,OADAxR,EAAyB,kBAAVA,EAAqBA,EAAQuR,EAAME,MAAMzR,GACjD,eAASA,GAASuR,EAAMG,iBAAiB1R,GAASwR,EAU3D,SAASG,GAAgBC,EAAQjR,EAASkD,GACxC,MAAMgO,EAAUlR,EAAQkD,GACxB,GAAIgO,GAAmB,YAARhO,EACb,OAAOgO,EAET,MAAMhR,EAAOgD,EAAIiO,OAAO,GAClBC,EAAOjO,OAAOkO,OAAOJ,GAAQpQ,OAAQ+P,GAAUA,EAAM1Q,MAAQ0Q,EAAM1Q,OAASA,GAClF,OAAIkR,EAAK7O,OACA6O,EAAK,GAAGE,GAEVpR,EAQT,SAASqR,GAAoBX,EAAO5Q,GAClC,GAAI4Q,EAAO,CACT,MAAMY,EAAUZ,EAAM5Q,QAAQwR,QACxB1O,EAAQ6N,GAAWC,EAAO5Q,EAAQV,IAAKkS,EAAUxR,EAAQ+C,IAAM/C,EAAQ8C,OACvEC,EAAM4N,GAAWC,EAAO5Q,EAAQT,IAAKiS,EAAUxR,EAAQ8C,MAAQ9C,EAAQ+C,KAC7E,MAAO,CACLD,QACAC,QAUN,SAAS0O,GAActJ,EAAOnI,GAC5B,MAAM,UAAC0R,EAAS,OAAET,GAAU9I,EACtBwJ,EAASV,EAAOD,GAAgBC,EAAQjR,EAAS,aACjD4R,EAASX,EAAOD,GAAgBC,EAAQjR,EAAS,aACvD,IAAIS,EAAIiR,EAAUlM,MAAQ,EACtB9E,EAAIgR,EAAUjM,OAAS,EAS3B,OAPIkM,IACFlR,EAAIkQ,GAAWgB,EAAQ3R,EAAQ+H,OAAQ4J,EAAOE,KAAOF,EAAOnM,MAAQ,IAGlEoM,IACFlR,EAAIiQ,GAAWiB,EAAQ5R,EAAQgI,OAAQ4J,EAAOE,IAAMF,EAAOnM,OAAS,IAE/D,CAAChF,IAAGC,KAQb,SAASqR,GAAqB5J,EAAOnI,GACnC,MAAMiR,EAAS9I,EAAM8I,OACfU,EAASV,EAAOD,GAAgBC,EAAQjR,EAAS,aACjD4R,EAASX,EAAOD,GAAgBC,EAAQjR,EAAS,aAEvD,IAAK2R,IAAWC,EACd,MAAO,GAGT,IAAKC,KAAMpR,EAAGuR,MAAOvO,GAAMkO,GAAUxJ,EAAMuJ,WACtCI,IAAKpR,EAAGuR,OAAQvO,GAAMkO,GAAUzJ,EAAMuJ,UAC3C,MAAMQ,EAAOC,GAAyBR,EAAQ,CAACrS,IAAKU,EAAQoS,KAAM7S,IAAKS,EAAQqS,KAAMvP,MAAOrC,EAAGsC,IAAKU,IACpGhD,EAAIyR,EAAKpP,MACTW,EAAKyO,EAAKnP,IACV,MAAMuP,EAAOH,GAAyBP,EAAQ,CAACtS,IAAKU,EAAQuS,KAAMhT,IAAKS,EAAQwS,KAAM1P,MAAOY,EAAIX,IAAKrC,IAIrG,OAHAA,EAAI4R,EAAKxP,MACTY,EAAK4O,EAAKvP,IAEH,CACLtC,IACAC,IACA+C,KACAC,KACA8B,MAAO/B,EAAKhD,EACZgF,OAAQ/B,EAAKhD,EACb2D,QAAS5D,GAAKgD,EAAKhD,GAAK,EACxB6D,QAAS5D,GAAKgD,EAAKhD,GAAK,GAS5B,SAAS+R,GAAuBtK,EAAOnI,GACrC,IAAK8H,EAAe9H,GAAU,CAC5B,MAAM2F,EAAMoM,GAAqB5J,EAAOnI,GACxC,IAAIsD,EAAStD,EAAQsD,OAChBA,IAAU6F,MAAM7F,KACnBA,EAAStB,KAAK1C,IAAIqG,EAAIH,MAAOG,EAAIF,QAAU,EAC3CzF,EAAQsD,OAASA,GAEnB,MAAM6C,EAAgB,EAAT7C,EACPoP,EAAgB/M,EAAItB,QAAUrE,EAAQ2G,QACtCgM,EAAgBhN,EAAIrB,QAAUtE,EAAQ4G,QAC5C,MAAO,CACLnG,EAAGiS,EAAgBpP,EACnB5C,EAAGiS,EAAgBrP,EACnBG,GAAIiP,EAAgBpP,EACpBI,GAAIiP,EAAgBrP,EACpBe,QAASqO,EACTpO,QAASqO,EACTnN,MAAOW,EACPV,OAAQU,EACR7C,UAGJ,OAAOsP,GAAezK,EAAOnI,GAO/B,SAAS6S,GAAsB1K,EAAOnI,GACpC,MAAM,OAACiR,EAAM,UAAES,GAAavJ,EACtByI,EAAQK,EAAOjR,EAAQkR,SACvB4B,EAAO,CAACrS,EAAGiR,EAAUG,KAAMnR,EAAGgR,EAAUI,IAAKrO,GAAIiO,EAAUM,MAAOtO,GAAIgO,EAAUO,QAOtF,OALIrB,EACFmC,GAA0BnC,EAAOkC,EAAM9S,GAEvCgT,GAA6B/B,EAAQ6B,EAAM9S,GAEtC8S,EAST,SAASG,GAA6B9K,EAAOnI,GAC3C,MAAM4F,EAAamM,GAAqB5J,EAAOnI,GAQ/C,OAPA4F,EAAWsN,eAAiBhL,EAAwBC,EAAOvC,EAAY5F,GACvE4F,EAAWuN,SAAW,CAAC,CACrBrK,KAAM,QACNsK,YAAa,QACbxN,WAAYyN,GAAgClL,EAAOvC,EAAY5F,GAC/DkT,eAAgBtN,EAAWsN,iBAEtBtN,EAGT,SAASgN,GAAezK,EAAOnI,GAC7B,MAAM6B,EAAQ4P,GAActJ,EAAOnI,GAC7BmG,EAAwB,EAAjBnG,EAAQsD,OACrB,MAAO,CACL7C,EAAGoB,EAAMpB,EAAIT,EAAQsD,OAAStD,EAAQ2G,QACtCjG,EAAGmB,EAAMnB,EAAIV,EAAQsD,OAAStD,EAAQ4G,QACtCnD,GAAI5B,EAAMpB,EAAIT,EAAQsD,OAAStD,EAAQ2G,QACvCjD,GAAI7B,EAAMnB,EAAIV,EAAQsD,OAAStD,EAAQ4G,QACvCvC,QAASxC,EAAMpB,EAAIT,EAAQ2G,QAC3BrC,QAASzC,EAAMnB,EAAIV,EAAQ4G,QAC3BtD,OAAQtD,EAAQsD,OAChBkC,MAAOW,EACPV,OAAQU,GAIZ,SAASgM,GAAyBvB,EAAO5Q,GACvC,MAAM+I,EAASwI,GAAoBX,EAAO5Q,IAAYA,EACtD,MAAO,CACL8C,MAAOd,KAAK1C,IAAIyJ,EAAOjG,MAAOiG,EAAOhG,KACrCA,IAAKf,KAAKzC,IAAIwJ,EAAOjG,MAAOiG,EAAOhG,MAIvC,SAASgQ,GAA0BnC,EAAOkC,EAAM9S,GAC9C,MAAMV,EAAMqR,GAAWC,EAAO5Q,EAAQX,MAAOiU,KACvC/T,EAAMoR,GAAWC,EAAO5Q,EAAQuT,SAAUjU,GAC5CsR,EAAM4C,gBACRV,EAAKrS,EAAInB,EACTwT,EAAKrP,GAAKlE,IAEVuT,EAAKpS,EAAIpB,EACTwT,EAAKpP,GAAKnE,GAId,SAASyT,GAA6B/B,EAAQ6B,EAAM9S,GAClD,IAAK,MAAMyT,KAAWtQ,OAAOC,KAAKkN,IAAmB,CACnD,MAAMM,EAAQK,EAAOD,GAAgBC,EAAQjR,EAASyT,IACtD,GAAI7C,EAAO,CACT,MAAM,IAACtR,EAAG,IAAEC,EAAG,MAAEuD,EAAK,IAAEC,EAAG,UAAEyN,EAAS,QAAEC,GAAWH,GAAiBmD,GAC9DC,EAAMnC,GAAoBX,EAAO,CAACtR,IAAKU,EAAQV,GAAMC,IAAKS,EAAQT,GAAMuD,MAAO8N,EAAM9N,GAAQC,IAAK6N,EAAM7N,KAC9G+P,EAAKtC,GAAakD,EAAI5Q,MACtBgQ,EAAKrC,GAAWiD,EAAI3Q,MAK1B,SAAS4Q,IAAW,WAAC/N,EAAU,QAAE5F,GAAU0G,EAAWN,EAAUS,GAC9D,MAAOpG,EAAGqC,EAAOW,GAAIV,EAAKyC,MAAOW,GAAQP,EACzC,OAAOgO,GAAkB,CAAC9Q,QAAOC,MAAKoD,OAAMxC,YAAa3D,EAAQ2D,aAAc,CAC7EyC,SAAUA,EAAS3F,EACnBoG,QAAS,CAAC/D,MAAO+D,EAAQgL,KAAM9O,IAAK8D,EAAQmL,OAC5C/J,OAAQjI,EAAQ+F,MAAMY,QACtBR,KAAMO,EAAUlB,QAIpB,SAASqO,IAAW,WAACjO,EAAU,QAAE5F,GAAU0G,EAAWN,EAAUS,GAC9D,MAAOnG,EAAGoC,EAAOY,GAAIX,EAAK0C,OAAQU,GAAQP,EAC1C,OAAOgO,GAAkB,CAAC9Q,QAAOC,MAAKoD,OAAMxC,YAAa3D,EAAQ2D,aAAc,CAC7EyC,SAAUA,EAAS1F,EACnBmG,QAAS,CAAC/D,MAAO+D,EAAQiL,IAAK/O,IAAK8D,EAAQoL,QAC3ChK,OAAQjI,EAAQ+F,MAAMa,QACtBT,KAAMO,EAAUjB,SAIpB,SAASmO,GAAkBE,EAASC,GAClC,MAAM,MAACjR,EAAK,IAAEC,EAAG,YAAEY,GAAemQ,GAC5B,SAAC1N,EAAUS,SAAU/D,MAAOkR,EAAUjR,IAAKkR,GAAO,OAAEhM,GAAU8L,EAC9DG,EAAgBnR,EAAMY,EAAcb,EAAQkR,EAAWC,EAASF,EAAU5N,KAChF,OAAOrD,EAAQa,EAAc,EAAIsE,EAAS/B,EAAoBgO,EAAe9N,GAG/E,SAASiN,GAAgClL,EAAOvC,EAAY5F,GAC1D,MAAM+F,EAAQ/F,EAAQ+F,MACtBA,EAAMgG,gBAAkB,cACxBhG,EAAMkJ,QAAQE,SAAU,EACxB,MAAM/I,EAAWY,EAAWjB,EAAMK,UAC5BS,EAAU,eAAUd,EAAMc,SAC1BH,EAAYsE,EAAiB7C,EAAMyB,IAAK7D,GACxCtF,EAAIkT,GAAW,CAAC/N,aAAY5F,WAAU0G,EAAWN,EAAUS,GAC3DnG,EAAImT,GAAW,CAACjO,aAAY5F,WAAU0G,EAAWN,EAAUS,GAC3DrB,EAAQkB,EAAUlB,MAAQqB,EAAQrB,MAClCC,EAASiB,EAAUjB,OAASoB,EAAQpB,OAC1C,MAAO,CACLhF,IACAC,IACA+C,GAAIhD,EAAI+E,EACR9B,GAAIhD,EAAI+E,EACRD,QACAC,SACApB,QAAS5D,EAAI+E,EAAQ,EACrBlB,QAAS5D,EAAI+E,EAAS,EACtBxB,SAAU8B,EAAM9B,UAKpB,MAAMkQ,GAAY,CAAC,QAAS,SAOtBC,GAAaD,GAAUE,OAAO,SAOpC,SAASC,GAAgBnM,EAAOoM,EAAOvU,GACrCuU,EAAMC,SAAWhM,EAAUxI,EAASoU,GAAYG,EAAME,WACtDF,EAAMG,cAAe,EAErBP,GAAUvL,QAAQC,IACZ,eAAW7I,EAAQ6I,MACrB0L,EAAMG,cAAe,KAIpBH,EAAMC,UAAaD,EAAMG,cAC5BH,EAAMI,YAAY/L,QAAQgM,KACnBL,EAAMC,UAAY,eAAWI,EAAMC,SACtCN,EAAMC,UAAW,GAEdD,EAAMG,cACTP,GAAUvL,QAAQC,IACZ,eAAW+L,EAAM/L,MACnB0L,EAAMC,UAAW,EACjBD,EAAMG,cAAe,OAcjC,SAASI,GAAYP,EAAO1U,EAAOG,GACjC,GAAIuU,EAAMC,SACR,OAAQ3U,EAAMiJ,MACd,IAAK,YACL,IAAK,WACH,OAAOiM,GAAiBR,EAAO1U,EAAOG,GACxC,IAAK,QACH,OAAOgV,GAAkBT,EAAO1U,EAAOG,IAK7C,SAAS+U,GAAiBR,EAAO1U,EAAOG,GACtC,IAAKuU,EAAMG,aACT,OAGF,IAAIvB,EAGFA,EADiB,cAAftT,EAAMiJ,KACG3I,EAAYoU,EAAM3U,gBAAiBC,EAAOG,EAAQN,aAElD,GAGb,MAAMuV,EAAWV,EAAMW,QACvBX,EAAMW,QAAU/B,EAEhB,MAAMgC,EAAU,CAACZ,QAAO1U,SACxB,IAAIuV,EAAUC,GAAmBF,EAAS,QAASF,EAAU9B,GAC7D,OAAOkC,GAAmBF,EAAS,QAAShC,EAAU8B,IAAaG,EAGrE,SAASC,IAAmB,MAACd,EAAK,MAAE1U,GAAQgJ,EAAMsK,EAAUmC,GAC1D,IAAIF,EACJ,IAAK,MAAM7U,KAAW4S,EAChBmC,EAAcC,QAAQhV,GAAW,IACnC6U,EAAUI,GAAcjV,EAAQP,QAAQ6I,IAAS0L,EAAME,UAAU5L,GAAOtI,EAASV,IAAUuV,GAG/F,OAAOA,EAGT,SAASJ,GAAkBT,EAAO1U,EAAOG,GACvC,MAAMyU,EAAYF,EAAME,UAClBtB,EAAWhT,EAAYoU,EAAM3U,gBAAiBC,EAAOG,EAAQN,aACnE,IAAI0V,EACJ,IAAK,MAAM7U,KAAW4S,EACpBiC,EAAUI,GAAcjV,EAAQP,QAAQ6U,OAASJ,EAAUI,MAAOtU,EAASV,IAAUuV,EAEvF,OAAOA,EAGT,SAASI,GAAcC,EAASlV,EAASV,GACvC,OAAwD,IAAjD,eAAS4V,EAAS,CAAClV,EAAQmV,SAAU7V,IAS9C,MAAM8V,GAAe,CAAC,YAAa,cAOnC,SAASC,GAAYzN,EAAOoM,EAAOvU,GACjC,MAAMJ,EAAkB2U,EAAM3U,gBAC9B2U,EAAMsB,OAASrN,EAAUxI,EAAS2V,GAAcpB,EAAM9L,OAEjD8L,EAAMsB,QACTjW,EAAgBgJ,QAAQgM,IACjBL,EAAMsB,QACTF,GAAa/M,QAAQC,IACf,eAAW+L,EAAM5U,QAAQ6I,MAC3B0L,EAAMsB,QAAS,OAa3B,SAASC,GAAWvB,EAAOhU,EAASsI,GAClC,GAAI0L,EAAMsB,OAAQ,CAChB,MAAME,EAAexV,EAAQP,QAAQ6I,IAAS0L,EAAM9L,MAAMI,GAC1D,OAAO,eAASkN,EAAc,CAACxV,EAAQmV,YAe3C,SAASM,GAAiB7N,EAAOyI,EAAO+D,GACtC,MAAMsB,EAAQC,GAAe/N,EAAM8I,OAAQL,EAAO+D,GAClD,IAAIS,EAAUe,GAAiBvF,EAAOqF,EAAO,MAAO,gBACpDb,EAAUe,GAAiBvF,EAAOqF,EAAO,MAAO,iBAAmBb,EAC/DA,GAAW,eAAWxE,EAAMwF,yBAC9BxF,EAAMwF,yBAQV,SAASC,GAAmB1B,EAAa1D,GACvC,IAAK,MAAMqF,KAAc3B,EACvB4B,GAAeD,EAAYrF,GAI/B,SAASkF,GAAiBvF,EAAOqF,EAAOrT,EAAO4T,GAC7C,GAAI,eAASP,EAAMrT,MAAY6T,GAAkB7F,EAAM5Q,QAAS4C,EAAO4T,GAAiB,CACtF,MAAMpB,EAAUxE,EAAMhO,KAAWqT,EAAMrT,GAEvC,OADAgO,EAAMhO,GAASqT,EAAMrT,GACdwS,GAIX,SAASqB,GAAkBC,EAAc9T,EAAO4T,GAC9C,OAAO,eAAQE,EAAa9T,KAAW,eAAQ8T,EAAaF,IAG9D,SAASD,GAAeD,EAAYrF,GAClC,IAAK,MAAM/N,IAAO,CAAC,UAAW,WAAY,YAAa,CACrD,MAAMgO,EAAUF,GAAgBC,EAAQqF,EAAYpT,GAChDgO,IAAYD,EAAOC,IAAYyF,GAAiBL,EAAYpT,IAC9D0T,QAAQC,KAAK,2BAA2B3F,sBAA4BoF,EAAWhF,QAKrF,SAASqF,GAAiBL,EAAYpT,GACpC,GAAY,YAARA,EACF,OAAO,EAET,MAAMhD,EAAOgD,EAAIiO,OAAO,GACxB,IAAK,MAAM2F,IAAQ,CAAC,MAAO,MAAO,SAChC,GAAI,eAAQR,EAAWpW,EAAO4W,IAC5B,OAAO,EAGX,OAAO,EAGT,SAASZ,GAAejF,EAAQL,EAAO+D,GACrC,MAAMzU,EAAO0Q,EAAM1Q,KACbgR,EAAUN,EAAMU,GAChByF,EAAgB7W,EAAO,UACvB8W,EAAS,CACb1X,IAAK,eAAesR,EAAMtR,IAAKyB,OAAOkW,mBACtC1X,IAAK,eAAeqR,EAAMrR,IAAKwB,OAAOC,oBAExC,IAAK,MAAMsV,KAAc3B,EACnB2B,EAAWpF,UAAYA,EACzBgG,GAAaZ,EAAY1F,EAAO,CAAC,QAAS,YAAaoG,GAC9ChG,GAAgBC,EAAQqF,EAAYS,KAAmB7F,GAChEgG,GAAaZ,EAAY1F,EAAO,CAAC1Q,EAAO,MAAOA,EAAO,MAAOA,EAAO,SAAU8W,GAGlF,OAAOA,EAGT,SAASE,GAAaZ,EAAY1F,EAAOuG,EAAOH,GAC9C,IAAK,MAAMF,KAAQK,EAAO,CACxB,MAAMC,EAAMd,EAAWQ,GACvB,GAAI,eAAQM,GAAM,CAChB,MAAM/X,EAAQuR,EAAME,MAAMsG,GAC1BJ,EAAO1X,IAAM0C,KAAK1C,IAAI0X,EAAO1X,IAAKD,GAClC2X,EAAOzX,IAAMyC,KAAKzC,IAAIyX,EAAOzX,IAAKF,KAKxC,MAAMgY,WAAsB,OAE1B,QAAQC,EAAQC,EAAQrX,EAAMkE,GAC5B,MAAM,EAAC3D,EAAC,EAAEC,GAAKkB,EAAQ,CAACnB,EAAG6W,EAAQ5W,EAAG6W,GAASC,KAAKrW,eAAeiD,GAAmB,gBAAWoT,KAAKxX,QAAQiE,WAC9G,OAAOT,EAAW,CAAC/C,IAAGC,KAAI8W,KAAKjT,SAAS,CAAC,IAAK,IAAK,KAAM,MAAOH,GAAmBlE,EAAMsX,KAAKxX,SAGhG,eAAeoE,GACb,OAAOD,EAAsBqT,KAAMpT,GAGrC,KAAKwF,GACHA,EAAIgC,OACJjC,EAAUC,EAAK4N,KAAKrW,iBAAkBqW,KAAKxX,QAAQiE,UACnD0H,EAAQ/B,EAAK4N,KAAMA,KAAKxX,SACxB4J,EAAI2C,UAGN,YACE,OAAOiL,KAAKrE,UAAYqE,KAAKrE,SAAS,GAGxC,yBAAyBhL,EAAOnI,GAC9B,OAAOiT,GAA6B9K,EAAOnI,IAI/CqX,GAAc/F,GAAK,gBAEnB+F,GAAcI,SAAW,CACvBzB,kBAAkB,EAClBpL,sBAAuB,cACvBZ,eAAgB,OAChBE,WAAY,GACZE,iBAAkB,EAClBE,gBAAiB,QACjB6B,aAAc,EACdG,kBAAmB,cACnB3I,YAAa,EACbwL,SAAS,EACT9G,UAAMqP,EACN9T,aAAc,EACdmC,MAAO,CACLgG,gBAAiB,cACjBpI,YAAa,EACbsL,QAAS,CACPE,SAAS,GAEXnC,MAAO,QACPvD,QAAS,KACT0F,SAAS,EACTwI,cAAUD,EACVlQ,KAAM,CACJoQ,YAAQF,EACR7P,gBAAY6P,EACZvR,UAAMuR,EACN9K,WAAO8K,EACPG,OAAQ,QAEVpS,YAAQiS,EACR9T,kBAAc8T,EACd/K,aAAS+K,EACT7Q,QAAS,EACTT,SAAU,SACVnC,cAAUyT,EACVlR,UAAW,QACX+G,qBAAiBmK,EACjBxM,gBAAiB,EACjB1F,WAAOkS,EACP/Q,QAAS,EACTC,QAAS,EACTkR,OAAGJ,GAELzT,SAAU,EACV4G,WAAY,EACZC,cAAe,EACfC,cAAe,EACfsH,UAAMqF,EACNtF,UAAMsF,EACNnH,cAAUmH,EACVlF,UAAMkF,EACNnF,UAAMmF,EACNhH,cAAUgH,EACVI,EAAG,GAGLT,GAAcU,cAAgB,CAC5BtN,YAAa,QACbsB,gBAAiB,SAGnBsL,GAAcW,YAAc,CAC1BjS,MAAO,CACLkS,WAAW,IAIf,MAAMC,WAAgC,OAEpC,QAAQZ,EAAQC,EAAQrX,EAAMkE,GAC5B,OAAOL,EACL,CAACtD,EAAG6W,EAAQ5W,EAAG6W,GACf,CAACvT,KAAMwT,KAAKjT,SAAS,CAAC,IAAK,IAAK,KAAM,MAAOH,GAAmBxD,OAAQ4W,KAAKrW,eAAeiD,IAC5FlE,EACA,CAAC+D,SAAUuT,KAAKvT,SAAUN,YAAa,EAAGC,aAAc4T,KAAKxX,QAAQ4D,eAIzE,eAAeQ,GACb,OAAOD,EAAsBqT,KAAMpT,GAGrC,KAAKwF,GACH,MAAM5J,EAAUwX,KAAKxX,QAChBA,EAAQmP,SAAYnP,EAAQyJ,UAGjC0O,GAAevO,EAAK4N,MACpB5N,EAAIgC,OACJjC,EAAUC,EAAK4N,KAAKrW,iBAAkBqW,KAAKvT,UAC3CuI,EAAU5C,EAAK4N,KAAMxX,EAASwX,KAAKY,WACnCxO,EAAI2C,WAGN,yBAAyBpE,EAAOnI,GAC9B,MAAMqY,EAAOC,GAAenQ,EAAOnI,GACnC,IAAKqY,EACH,MAAO,GAET,MAAM,eAACE,EAAc,MAAE1W,EAAK,OAAEyB,GAAUkV,GAAkBrQ,EAAOnI,EAASqY,GAC1E,IAAI3R,EAAYsE,EAAiB7C,EAAMyB,IAAK5J,GAC5C,MAAMoY,EAAYK,GAAY/R,EAAWpD,GACrC6D,EAAUnH,EAASoY,KACrB1R,EAAY,CAAClB,MAAOkB,EAAUlB,MAAQ4S,EAAW3S,OAAQiB,EAAUjB,OAAS2S,IAE9E,MAAM,SAAChS,EAAQ,QAAEO,EAAO,QAAEC,GAAW5G,EAC/B0Y,EAAUjS,EAAsB5E,EAAO6E,EAAW,CAAC/C,YAAa,EAAGyC,WAAUO,UAASC,YAC5F,MAAO,CACLsM,eAAgBhL,EAAwBC,EAAOuQ,EAAS1Y,MACrD0Y,KACAH,EACHtU,SAAUjE,EAAQiE,SAClBmU,cAiDN,SAASE,GAAenQ,EAAOnI,GAC7B,OAAOmI,EAAMwQ,+BAA+B1X,QAAO,SAAS8H,EAAQ1J,GAClE,MAAMuZ,EAAavZ,EAAMuZ,WACzB,OAAIA,aAAsB,QACxBC,GAAoB1Q,EAAOnI,EAASX,EAAMyZ,SACxC/P,GAAU6P,EAAWG,YAAchQ,EAAO6P,WAAWG,cACvDH,EAAW5Y,QAAQgZ,eAAiB,GAC7B3Z,EAEF0J,SACN2O,GAGL,SAASmB,GAAoB1Q,EAAOnI,EAASmT,GAC3C,IAAKnT,EAAQiZ,SACX,OAAO,EAET,IAAK,IAAInU,EAAI,EAAGA,EAAIqO,EAAS5Q,OAAQuC,IACnC,IAAKqO,EAASrO,GAAGoU,QAAU/Q,EAAMgR,kBAAkBrU,GACjD,OAAO,EAKb,SAAS0T,IAAkB,UAAC9G,GAAY1R,EAASqY,GAC/C,MAAM,KAACxG,EAAI,IAAEC,EAAG,MAAEE,EAAK,OAAEC,GAAUP,GAC7B,YAACqH,EAAW,QAAEK,EAAO,QAAEC,GAAWhB,EAAKO,WACvCnY,GAAKoR,EAAOG,GAAS,EAAIoH,EACzB1Y,GAAKoR,EAAMG,GAAU,EAAIoH,EACzBC,EAAS,CACbzH,KAAM7P,KAAKzC,IAAIkB,EAAIsY,EAAalH,GAChCG,MAAOhQ,KAAK1C,IAAImB,EAAIsY,EAAa/G,GACjCF,IAAK9P,KAAKzC,IAAImB,EAAIqY,EAAajH,GAC/BG,OAAQjQ,KAAK1C,IAAIoB,EAAIqY,EAAa9G,IAE9BpQ,EAAQ,CACZpB,GAAI6Y,EAAOzH,KAAOyH,EAAOtH,OAAS,EAClCtR,GAAI4Y,EAAOxH,IAAMwH,EAAOrH,QAAU,GAE9BsH,EAAQvZ,EAAQwZ,QAAUxZ,EAAQ2D,YAAc,EAChD8V,EAAUV,EAAcQ,EACxBG,EAAoB7X,EAAMnB,EAAIA,EAC9BqP,EAAO2J,EAAoB5H,EAAMyH,EAAQtH,EAASsH,EAClDI,EAASC,GAAU7J,EAAMtP,EAAGC,EAAG+Y,GAC/BlB,EAAiB,CACrBsB,SAAUpZ,EACVqZ,SAAUpZ,EACV+Y,UACAC,uBACGC,GAEL,MAAO,CACLpB,iBACA1W,QACAyB,OAAQtB,KAAK1C,IAAIyZ,EAAa/W,KAAK1C,IAAIga,EAAOtH,MAAQsH,EAAOzH,KAAMyH,EAAOrH,OAASqH,EAAOxH,KAAO,IAIrG,SAAS2G,IAAY,MAACjT,EAAK,OAAEC,GAASnC,GACpC,MAAMyW,EAAO/X,KAAKgY,KAAKhY,KAAKuB,IAAIiC,EAAO,GAAKxD,KAAKuB,IAAIkC,EAAQ,IAC7D,OAAiB,EAATnC,EAAcyW,EAGxB,SAASH,GAAUlZ,EAAG2D,EAASC,EAAShB,GACtC,MAAM2W,EAAMjY,KAAKuB,IAAIe,EAAU5D,EAAG,GAC5BwZ,EAAKlY,KAAKuB,IAAID,EAAQ,GACtB7B,GAAe,EAAX4C,EACJqK,EAAI1M,KAAKuB,IAAIc,EAAS,GAAK4V,EAAMC,EACjCC,EAAQnY,KAAKuB,IAAI9B,EAAG,GAAM,EAAIiN,EACpC,GAAIyL,GAAS,EACX,MAAO,CACLC,YAAa,EACbC,UAAW,QAGf,MAAMvX,IAAUrB,EAAIO,KAAKgY,KAAKG,IAAU,EAClCpX,IAAQtB,EAAIO,KAAKgY,KAAKG,IAAU,EACtC,MAAO,CACLC,YAAa,eAAkB,CAAC3Z,EAAG4D,EAAS3D,EAAG4D,GAAU,CAAC7D,EAAGqC,EAAOpC,MAAIoB,MACxEuY,UAAW,eAAkB,CAAC5Z,EAAG4D,EAAS3D,EAAG4D,GAAU,CAAC7D,EAAGsC,EAAKrC,MAAIoB,OAIxE,SAASqW,GAAevO,EAAKrJ,GAC3B,MAAM,SAACsZ,EAAQ,SAAEC,EAAQ,QAAEL,EAAO,YAAEW,EAAW,UAAEC,EAAS,kBAAEX,EAAiB,QAAE1Z,GAAWO,EAC1FqJ,EAAIgC,OACJ,MAAMC,EAAS/B,EAAeF,EAAK5J,GACnC4J,EAAIkC,UAAY9L,EAAQ+L,gBACxBnC,EAAIoC,YACJpC,EAAImE,IAAI8L,EAAUC,EAAUL,EAASW,EAAaC,EAAWX,GAC7D9P,EAAIwC,YACJxC,EAAIyC,OACAR,GACFjC,EAAIiC,SAENjC,EAAI2C,UA3IN2L,GAAwB5G,GAAK,0BAE7B4G,GAAwBT,SAAW,CACjCpQ,SAAS,EACT4R,UAAU,EACVlN,gBAAiB,cACjBnB,sBAAuB,cACvBH,YAAa,cACbP,WAAY,GACZE,iBAAkB,EAClBE,gBAAiB,QACjBgC,kBAAmB,cACnB3I,YAAa,EACbqJ,MAAO,QACPvD,QAAS,KACT0F,SAAS,EACT3H,KAAM,CACJoQ,YAAQF,EACR7P,gBAAY6P,EACZvR,UAAMuR,EACN9K,WAAO8K,EACPG,YAAQH,GAEVjS,YAAQiS,EACR9T,aAAc,EACdyE,UAAMqP,EACN/K,aAAS+K,EACTtR,SAAU,SACVnC,SAAU,EACV4G,WAAY,EACZC,cAAe,EACfC,cAAe,EACfyO,QAAS,EACThT,UAAW,SACX+G,qBAAiBmK,EACjBxM,gBAAiB,EACjB1F,WAAOkS,EACP/Q,QAAS,EACTC,QAAS,GAGXsR,GAAwBH,cAAgB,GAqGxC,MAAMuC,WAAwB,OAE5B,QAAQhD,EAAQC,EAAQrX,EAAMkE,GAC5B,OAAOL,EACL,CAACtD,EAAG6W,EAAQ5W,EAAG6W,GACf,CAACvT,KAAMwT,KAAKjT,SAAS,CAAC,IAAK,IAAK,KAAM,MAAOH,GAAmBxD,OAAQ4W,KAAKrW,eAAeiD,IAC5FlE,EACA,CAAC+D,SAAUuT,KAAKvT,SAAUN,YAAa6T,KAAKxX,QAAQ2D,YAAaC,aAAc4T,KAAKxX,QAAQ4D,eAIhG,eAAeQ,GACb,OAAOD,EAAsBqT,KAAMpT,GAGrC,KAAKwF,GACH,MAAM5J,EAAUwX,KAAKxX,QACfua,GAAW,eAAQ/C,KAAKgD,WAAahD,KAAKgD,SAC3Cxa,EAAQmP,SAAYnP,EAAQyJ,SAAY8Q,IAG7C3Q,EAAIgC,OACJjC,EAAUC,EAAK4N,KAAKrW,iBAAkBqW,KAAKvT,UAC3C6K,GAAYlF,EAAK4N,MACjB7L,EAAQ/B,EAAK4N,KAAMxX,GACnBwM,EAAU5C,EAAK6Q,GAAajD,MAAOxX,GACnC4J,EAAI2C,WAGN,yBAAyBpE,EAAOnI,GAC9B,IAAI6B,EACJ,GAAKiG,EAAe9H,GAIlB6B,EAAQ4P,GAActJ,EAAOnI,OAJD,CAC5B,MAAM,QAACqE,EAAO,QAAEC,GAAWyN,GAAqB5J,EAAOnI,GACvD6B,EAAQ,CAACpB,EAAG4D,EAAS3D,EAAG4D,GAI1B,MAAMuC,EAAU,eAAU7G,EAAQ6G,SAC5BH,EAAYsE,EAAiB7C,EAAMyB,IAAK5J,GACxC0Y,EAAUjS,EAAsB5E,EAAO6E,EAAW1G,EAAS6G,GACjE,MAAO,CACLqM,eAAgBhL,EAAwBC,EAAOuQ,EAAS1Y,GACxD+O,OAAQlN,EAAMpB,EACduO,OAAQnN,EAAMnB,KACXgY,EACHzU,SAAUjE,EAAQiE,WAwExB,SAASwW,IAAa,EAACha,EAAC,EAAEC,EAAC,MAAE8E,EAAK,OAAEC,EAAM,QAAEzF,IAC1C,MAAM0a,EAAe1a,EAAQ2D,YAAc,EACrCkD,EAAU,eAAU7G,EAAQ6G,SAClC,MAAO,CACLpG,EAAGA,EAAIoG,EAAQgL,KAAO6I,EACtBha,EAAGA,EAAImG,EAAQiL,IAAM4I,EACrBlV,MAAOA,EAAQqB,EAAQgL,KAAOhL,EAAQmL,MAAQhS,EAAQ2D,YACtD8B,OAAQA,EAASoB,EAAQiL,IAAMjL,EAAQoL,OAASjS,EAAQ2D,aA1E5D2W,GAAgBhJ,GAAK,kBAErBgJ,GAAgB7C,SAAW,CACzBzB,kBAAkB,EAClBjK,gBAAiB,cACjBnB,sBAAuB,cACvBZ,eAAgB,OAChBE,WAAY,GACZE,iBAAkB,EAClBE,gBAAiB,QACjB6B,aAAc,EACdG,kBAAmB,cACnB3I,YAAa,EACbsL,QAAS,CACPjF,eAAgB,OAChBS,iBAAaiN,EACbxN,WAAY,GACZE,iBAAkB,EAClBE,gBAAiB,QACjB3G,YAAa,EACbwL,SAAS,EACTS,OAAQ,EACRxJ,SAAU,OACV2J,KAAM,EACNjN,MAAO,OAETkK,MAAO,QACPvD,QAAS,KACT0F,SAAS,EACT3H,KAAM,CACJoQ,YAAQF,EACR7P,gBAAY6P,EACZvR,UAAMuR,EACN9K,WAAO8K,EACPG,YAAQH,GAEVjS,YAAQiS,EACR9T,aAAc,EACdyE,UAAMqP,EACN/K,aAAS+K,EACT7Q,QAAS,EACTT,SAAU,SACVnC,SAAU,EACV4G,WAAY,EACZC,cAAe,EACfC,cAAe,EACfvE,UAAW,SACX+G,qBAAiBmK,EACjBxM,gBAAiB,EACjB1F,WAAOkS,EACP/Q,QAAS,EACT0L,UAAMqF,EACNtF,UAAMsF,EACNnH,cAAUmH,EACV3P,YAAQ2P,EACR9Q,QAAS,EACT4L,UAAMkF,EACNnF,UAAMmF,EACNhH,cAAUgH,EACV1P,YAAQ0P,EACRI,EAAG,GAGLwC,GAAgBvC,cAAgB,CAC9BtN,YAAa,SAcf,MAAMkQ,GAAc,CAACC,EAAIC,EAAIC,KAAM,CAAEra,EAAGma,EAAGna,EAAIqa,GAAKD,EAAGpa,EAAIma,EAAGna,GAAIC,EAAGka,EAAGla,EAAIoa,GAAKD,EAAGna,EAAIka,EAAGla,KACrFqa,GAAe,CAACra,EAAGka,EAAIC,IAAOF,GAAYC,EAAIC,EAAI7Y,KAAKgZ,KAAKta,EAAIka,EAAGla,IAAMma,EAAGna,EAAIka,EAAGla,KAAKD,EACxFwa,GAAe,CAACxa,EAAGma,EAAIC,IAAOF,GAAYC,EAAIC,EAAI7Y,KAAKgZ,KAAKva,EAAIma,EAAGna,IAAMoa,EAAGpa,EAAIma,EAAGna,KAAKC,EACxFwa,GAAMC,GAAKA,EAAIA,EACfC,GAAa,CAAC9D,EAAQC,GAAS9W,IAAGC,IAAG+C,KAAIC,MAAKxD,IAAkB,MAATA,EAAe,CAAC4C,MAAOd,KAAK1C,IAAIoB,EAAGgD,GAAKX,IAAKf,KAAKzC,IAAImB,EAAGgD,GAAKrE,MAAOkY,GAAU,CAACzU,MAAOd,KAAK1C,IAAImB,EAAGgD,GAAKV,IAAKf,KAAKzC,IAAIkB,EAAGgD,GAAKpE,MAAOiY,GAE5L+D,GAAe,CAACvY,EAAOwY,EAAIvY,EAAK+X,KAAO,EAAIA,IAAM,EAAIA,GAAKhY,EAAQ,GAAK,EAAIgY,GAAKA,EAAIQ,EAAKR,EAAIA,EAAI/X,EACjGwY,GAAe,CAACzY,EAAOwY,EAAIvY,EAAK+X,KAAM,CAAEra,EAAG4a,GAAavY,EAAMrC,EAAG6a,EAAG7a,EAAGsC,EAAItC,EAAGqa,GAAIpa,EAAG2a,GAAavY,EAAMpC,EAAG4a,EAAG5a,EAAGqC,EAAIrC,EAAGoa,KACxHU,GAAoB,CAAC1Y,EAAOwY,EAAIvY,EAAK+X,IAAM,GAAK,EAAIA,IAAMQ,EAAKxY,GAAS,EAAIgY,GAAK/X,EAAMuY,GACvFG,GAAe,CAAC3Y,EAAOwY,EAAIvY,EAAK+X,KAAO9Y,KAAK0Z,MAAMF,GAAkB1Y,EAAMrC,EAAG6a,EAAG7a,EAAGsC,EAAItC,EAAGqa,GAAIU,GAAkB1Y,EAAMpC,EAAG4a,EAAG5a,EAAGqC,EAAIrC,EAAGoa,IAAM,GAAM,OAExJ,MAAMa,WAAuB,OAE3B,QAAQrE,EAAQC,EAAQrX,EAAMkE,GAC5B,MAAMvB,GAAW2U,KAAKxX,QAAQ2D,YAAc6T,KAAKxX,QAAQ4D,cAAgB,EACzE,GAAa,MAAT1D,GAAyB,MAATA,EAAc,CAChC,MAAM2B,EAAQ,CAACyV,SAAQC,WACjB,KAACqE,EAAI,IAAEhS,GAAO4N,KACpB,GAAIoE,EAAM,CACR9R,EAAeF,EAAK4N,KAAKxX,SACzB4J,EAAIW,WAAaiN,KAAKxX,QAAQ4D,aAC9B,MAAM,MAACuE,GAASqP,KAAK9B,SACfmG,EAAKvE,EAASnP,EAAM2T,wBACpBC,EAAKxE,EAASpP,EAAM2T,wBACpB/S,EAASa,EAAIoS,gBAAgBJ,EAAMC,EAAIE,IAAOE,GAAUzE,KAAM3V,EAAOuC,GAE3E,OADAwF,EAAI2C,UACGxD,EAET,MAAMmT,EAAUhB,GAAIrY,GACpB,OAAOsZ,GAAW3E,KAAM3V,EAAOqa,EAAS9X,IAAqB6X,GAAUzE,KAAM3V,EAAOuC,GAEtF,OAAOgY,GAAY5E,KAAM,CAACF,SAAQC,UAASrX,EAAM,CAAC2C,UAASuB,qBAG7D,eAAeA,GACb,OAAOD,EAAsBqT,KAAMpT,GAGrC,KAAKwF,GACH,MAAM,EAACnJ,EAAC,EAAEC,EAAC,GAAE+C,EAAE,GAAEC,EAAE,GAAE4X,EAAE,QAAEtb,GAAWwX,KAGpC,GADA5N,EAAIgC,QACC9B,EAAeF,EAAK5J,GAEvB,OAAO4J,EAAI2C,UAEb7B,EAAed,EAAK5J,GAEpB,MAAMuC,EAASP,KAAKgY,KAAKhY,KAAKuB,IAAIE,EAAKhD,EAAG,GAAKuB,KAAKuB,IAAIG,EAAKhD,EAAG,IAChE,GAAIV,EAAQqc,OAASf,EAEnB,OADAgB,GAAU1S,EAAK4N,KAAM8D,EAAI/Y,GAClBqH,EAAI2C,UAEb,MAAM,UAACgQ,EAAS,QAAEC,EAAO,YAAEC,EAAW,UAAEC,GAAaC,GAAcnF,MAC7D1V,EAAQE,KAAK0Z,MAAMhY,EAAKhD,EAAG+C,EAAKhD,GACtCmJ,EAAID,UAAUlJ,EAAGC,GACjBkJ,EAAIC,OAAO/H,GACX8H,EAAIoC,YACJpC,EAAIoE,OAAO,EAAIyO,EAAa,GAC5B7S,EAAIqE,OAAO1L,EAASma,EAAW,GAC/B9S,EAAIe,YAAc3K,EAAQsM,kBAC1B1C,EAAIiC,SACJ+Q,GAAchT,EAAK,EAAG6S,EAAaF,GACnCK,GAAchT,EAAKrH,GAASma,EAAWF,GACvC5S,EAAI2C,UAGN,YACE,OAAOiL,KAAKrE,UAAYqE,KAAKrE,SAAS,GAGxC,yBAAyBhL,EAAOnI,GAC9B,MAAM8S,EAAOD,GAAsB1K,EAAOnI,IACpC,EAACS,EAAC,EAAEC,EAAC,GAAE+C,EAAE,GAAEC,GAAMoP,EACjB+J,EAASC,GAAahK,EAAM3K,EAAMuJ,WAClC9L,EAAaiX,EACfE,GAAgB,CAACtc,IAAGC,KAAI,CAACD,EAAGgD,EAAI/C,EAAGgD,GAAKyE,EAAMuJ,WAC9C,CAACjR,IAAGC,IAAG+C,KAAIC,KAAI8B,MAAOxD,KAAKgZ,IAAIvX,EAAKhD,GAAIgF,OAAQzD,KAAKgZ,IAAItX,EAAKhD,IAIlE,GAHAkF,EAAWvB,SAAWZ,EAAKhD,GAAK,EAChCmF,EAAWtB,SAAWZ,EAAKhD,GAAK,EAChCkF,EAAWsN,eAAiBhL,EAAwBC,EAAOvC,EAAY5F,GACnEA,EAAQqc,MAAO,CACjB,MAAMzB,EAAK,CAACna,EAAGmF,EAAWnF,EAAGC,EAAGkF,EAAWlF,GACrCma,EAAK,CAACpa,EAAGmF,EAAWnC,GAAI/C,EAAGkF,EAAWlC,IAC5CkC,EAAW0V,GAAK0B,GAAgBpX,EAAY5F,EAAS,eAAsB4a,EAAIC,IAEjF,MAAMoC,EAAkBC,GAA8B/U,EAAOvC,EAAY5F,EAAQ+F,OAUjF,OARAkX,EAAgBzC,SAAWqC,EAE3BjX,EAAWuN,SAAW,CAAC,CACrBrK,KAAM,QACNsK,YAAa,QACbxN,WAAYqX,EACZ/J,eAAgBtN,EAAWsN,iBAEtBtN,GAIX+V,GAAerK,GAAK,iBAEpB,MAAM6L,GAAqB,CACzBpR,qBAAiB2L,EACjB9M,2BAAuB8M,EACvBjN,iBAAaiN,EACbxN,gBAAYwN,EACZtN,sBAAkBsN,EAClBpL,uBAAmBoL,EACnB/T,iBAAa+T,EACbvI,aAASuI,EACTrL,UAAMqL,EACNnV,YAAQmV,EACR7M,gBAAY6M,EACZ5M,mBAAe4M,EACf3M,mBAAe2M,EACflS,WAAOkS,GA+FT,SAAS0E,GAAY7b,GAAS,OAAC+W,EAAM,OAAEC,GAASrX,GAAM,QAAC2C,EAAO,iBAAEuB,IAC9D,MAAMxB,EAAQwY,GAAW9D,EAAQC,EAAQhX,EAAQgE,SAAS,CAAC,IAAK,IAAK,KAAM,MAAOH,GAAmBlE,GACrG,OAAOyC,EAAQC,EAAOC,IAAYoZ,GAAU1b,EAAS,CAAC+W,SAAQC,UAASnT,EAAkBlE,GAG3F,SAAS4c,IAAa,EAACrc,EAAC,EAAEC,EAAC,GAAE+C,EAAE,GAAEC,IAAK,IAACoO,EAAG,MAAEE,EAAK,OAAEC,EAAM,KAAEJ,IACzD,QACGpR,EAAIoR,GAAQpO,EAAKoO,GACjBpR,EAAIuR,GAASvO,EAAKuO,GAClBtR,EAAIoR,GAAOpO,EAAKoO,GAChBpR,EAAIuR,GAAUvO,EAAKuO,GAIxB,SAASmL,IAAiB,EAAC3c,EAAC,EAAEC,GAAIma,GAAI,IAAC/I,EAAG,MAAEE,EAAK,OAAEC,EAAM,KAAEJ,IAiBzD,OAhBIpR,EAAIoR,IACNnR,EAAIua,GAAapJ,EAAM,CAACpR,IAAGC,KAAIma,GAC/Bpa,EAAIoR,GAEFpR,EAAIuR,IACNtR,EAAIua,GAAajJ,EAAO,CAACvR,IAAGC,KAAIma,GAChCpa,EAAIuR,GAEFtR,EAAIoR,IACNrR,EAAIsa,GAAajJ,EAAK,CAACrR,IAAGC,KAAIma,GAC9Bna,EAAIoR,GAEFpR,EAAIuR,IACNxR,EAAIsa,GAAa9I,EAAQ,CAACxR,IAAGC,KAAIma,GACjCna,EAAIuR,GAEC,CAACxR,IAAGC,KAGb,SAASqc,GAAgBnC,EAAIC,EAAI/H,GAC/B,MAAM,EAACrS,EAAC,EAAEC,GAAK0c,GAAiBxC,EAAIC,EAAI/H,IACjCrS,EAAGgD,EAAI/C,EAAGgD,GAAM0Z,GAAiBvC,EAAID,EAAI9H,GAChD,MAAO,CAACrS,IAAGC,IAAG+C,KAAIC,KAAI8B,MAAOxD,KAAKgZ,IAAIvX,EAAKhD,GAAIgF,OAAQzD,KAAKgZ,IAAItX,EAAKhD,IAGvE,SAASyb,GAAW5b,GAAS,OAAC+W,EAAM,OAAEC,GAAS2E,EAAU1Z,EAAS4B,GAEhE,MAAO3D,EAAG4c,EAAI3c,EAAG4c,EAAE,GAAE7Z,EAAE,GAAEC,GAAMnD,EAAQgE,SAAS,CAAC,IAAK,IAAK,KAAM,MAAOH,GAClEmZ,EAAK9Z,EAAK4Z,EACVG,EAAK9Z,EAAK4Z,EACVG,EAAQvC,GAAIqC,GAAMrC,GAAIsC,GACtB1C,EAAc,IAAV2C,GAAe,IAAMnG,EAAS+F,GAAME,GAAMhG,EAAS+F,GAAME,GAAMC,EAEzE,IAAIC,EAAIC,EAWR,OAVI7C,EAAI,GACN4C,EAAKL,EACLM,EAAKL,GACIxC,EAAI,GACb4C,EAAKja,EACLka,EAAKja,IAELga,EAAKL,EAAKvC,EAAIyC,EACdI,EAAKL,EAAKxC,EAAI0C,GAERtC,GAAI5D,EAASoG,GAAMxC,GAAI3D,EAASoG,IAAQzB,EAGlD,SAASD,GAAU1b,GAAS,OAAC+W,EAAM,OAAEC,GAASnT,EAAkBlE,GAC9D,MAAM6F,EAAQxF,EAAQwF,MACtB,OAAOA,EAAM/F,QAAQmP,SAAWpJ,EAAMvF,QAAQ8W,EAAQC,EAAQrX,EAAMkE,GAGtE,SAAS8Y,GAA8B/U,EAAOvC,EAAY5F,GACxD,MAAM2D,EAAc3D,EAAQ2D,YACtBkD,EAAU,eAAU7G,EAAQ6G,SAC5B+W,EAAW5S,EAAiB7C,EAAMyB,IAAK5J,GACvCwF,EAAQoY,EAASpY,MAAQqB,EAAQrB,MAAQ7B,EACzC8B,EAASmY,EAASnY,OAASoB,EAAQpB,OAAS9B,EAClD,OAAOka,GAAuBjY,EAAY5F,EAAS,CAACwF,QAAOC,SAAQoB,WAAUsB,EAAMuJ,WAGrF,SAASoM,GAAsBlY,GAC7B,MAAM,EAACnF,EAAC,EAAEC,EAAC,GAAE+C,EAAE,GAAEC,GAAMkC,EACjB3B,EAAWjC,KAAK0Z,MAAMhY,EAAKhD,EAAG+C,EAAKhD,GAEzC,OAAOwD,EAAW,OAAK,EAAIA,EAAW,OAAKA,EAAW,QAAM,EAAIA,EAAW,OAAKA,EAGlF,SAAS4Z,GAAuBjY,EAAYG,EAAOgY,EAAOrM,GACxD,MAAM,MAAClM,EAAK,OAAEC,EAAM,QAAEoB,GAAWkX,GAC3B,QAACpX,EAAO,QAAEC,GAAWb,EACrB6U,EAAK,CAACna,EAAGmF,EAAWnF,EAAGC,EAAGkF,EAAWlF,GACrCma,EAAK,CAACpa,EAAGmF,EAAWnC,GAAI/C,EAAGkF,EAAWlC,IACtCO,EAA8B,SAAnB8B,EAAM9B,SAAsB6Z,GAAsBlY,GAAc,eAAUG,EAAM9B,UAC3FkC,EAAO6X,GAAYxY,EAAOC,EAAQxB,GAClC6W,EAAImD,GAAWrY,EAAYG,EAAO,CAACW,UAAWP,EAAMU,WAAU6K,GAC9DwM,EAAKtY,EAAW0V,GAAKC,GAAaX,EAAIhV,EAAW0V,GAAIT,EAAIC,GAAKH,GAAYC,EAAIC,EAAIC,GAClFqD,EAAmB,CAAChY,KAAMA,EAAK8F,EAAG3M,IAAKoS,EAAUG,KAAMtS,IAAKmS,EAAUM,MAAOnL,QAASA,EAAQgL,MAC9FuM,EAAmB,CAACjY,KAAMA,EAAK+F,EAAG5M,IAAKoS,EAAUI,IAAKvS,IAAKmS,EAAUO,OAAQpL,QAASA,EAAQiL,KAC9FzN,EAAUga,GAAsBH,EAAGzd,EAAG0d,GAAoBxX,EAC1DrC,EAAU+Z,GAAsBH,EAAGxd,EAAG0d,GAAoBxX,EAChE,MAAO,CACLnG,EAAG4D,EAAWmB,EAAQ,EACtB9E,EAAG4D,EAAWmB,EAAS,EACvBhC,GAAIY,EAAWmB,EAAQ,EACvB9B,GAAIY,EAAWmB,EAAS,EACxBpB,UACAC,UACAyK,OAAQmP,EAAGzd,EACXuO,OAAQkP,EAAGxd,EACX8E,QACAC,SACAxB,SAAU,eAAUA,IAIxB,SAAS+Z,GAAYxY,EAAOC,EAAQxB,GAClC,MAAMlC,EAAMC,KAAKD,IAAIkC,GACfhC,EAAMD,KAAKC,IAAIgC,GACrB,MAAO,CACLgI,EAAGjK,KAAKgZ,IAAIxV,EAAQzD,GAAOC,KAAKgZ,IAAIvV,EAASxD,GAC7CiK,EAAGlK,KAAKgZ,IAAIxV,EAAQvD,GAAOD,KAAKgZ,IAAIvV,EAAS1D,IAIjD,SAASkc,GAAWrY,EAAYG,EAAOgY,EAAOrM,GAC5C,IAAIoJ,EACJ,MAAMvB,EAAQ+E,GAAY1Y,EAAY8L,GAQtC,OANEoJ,EADqB,UAAnB/U,EAAMK,SACJmY,GAAiB,CAACtS,EAAGrG,EAAWnC,GAAKmC,EAAWnF,EAAGyL,EAAGtG,EAAWlC,GAAKkC,EAAWlF,GAAIqd,EAAOhY,EAAOwT,GAC3E,QAAnBxT,EAAMK,SACX,EAAImY,GAAiB,CAACtS,EAAGrG,EAAWnF,EAAImF,EAAWnC,GAAIyI,EAAGtG,EAAWlF,EAAIkF,EAAWlC,IAAKqa,EAAOhY,EAAOwT,GAEvGrT,EAAoB,EAAGH,EAAMK,UAE5B0U,EAGT,SAASyD,GAAiBC,EAAUT,EAAOhY,EAAOwT,GAChD,MAAM,UAAC7S,EAAS,QAAEG,GAAWkX,EACvBU,EAAQD,EAASvS,EAAIsN,EAAMgE,GAC3BmB,EAAQF,EAAStS,EAAIqN,EAAMiE,GAC3B/c,EAAKge,EAAQ,IAAQ/X,EAAUuF,EAAI,EAAIpF,EAAQgL,KAAO0H,EAAM9Y,GAAKge,EACjE/d,EAAKge,EAAQ,IAAQhY,EAAUwF,EAAI,EAAIrF,EAAQiL,IAAMyH,EAAM7Y,GAAKge,EACtE,OAAOtf,EAAM4C,KAAKzC,IAAIkB,EAAGC,GAAI,EAAG,KAGlC,SAAS4d,GAAY1Y,EAAY8L,GAC/B,MAAM,EAACjR,EAAC,GAAEgD,EAAE,EAAE/C,EAAC,GAAEgD,GAAMkC,EACjBkV,EAAI9Y,KAAK1C,IAAIoB,EAAGgD,GAAMgO,EAAUI,IAChCvD,EAAIvM,KAAK1C,IAAImB,EAAGgD,GAAMiO,EAAUG,KAChCpQ,EAAIiQ,EAAUO,OAASjQ,KAAKzC,IAAImB,EAAGgD,GACnCib,EAAIjN,EAAUM,MAAQhQ,KAAKzC,IAAIkB,EAAGgD,GACxC,MAAO,CACLhD,EAAGuB,KAAK1C,IAAIiP,EAAGoQ,GACfje,EAAGsB,KAAK1C,IAAIwb,EAAGrZ,GACf8b,GAAIhP,GAAKoQ,EAAI,GAAK,EAClBnB,GAAI1C,GAAKrZ,EAAI,GAAK,GAItB,SAAS4c,GAAsBO,EAAYC,GACzC,MAAM,KAAC1Y,EAAI,IAAE7G,EAAG,IAAEC,EAAG,QAAEsH,GAAWgY,EAC5BC,EAAW3Y,EAAO,EACxB,OAAIA,EAAO5G,EAAMD,GAEPC,EAAMD,GAAO,GAEnBA,GAAQsf,EAAa/X,EAAUiY,IACjCF,EAAatf,EAAMuH,EAAUiY,GAE3Bvf,GAAQqf,EAAa/X,EAAUiY,IACjCF,EAAarf,EAAMsH,EAAUiY,GAExBF,GAGT,SAASjC,GAAc3W,GACrB,MAAMhG,EAAUgG,EAAKhG,QACf+e,EAAiB/e,EAAQgf,YAAchf,EAAQgf,WAAWlc,MAC1Dmc,EAAejf,EAAQgf,YAAchf,EAAQgf,WAAWjc,IAC9D,MAAO,CACLwZ,UAAWwC,EACXvC,QAASyC,EACTxC,YAAayC,GAAclZ,EAAM+Y,GACjCrC,UAAWwC,GAAclZ,EAAMiZ,IAInC,SAASC,GAAclZ,EAAMmZ,GAC3B,IAAKA,IAAcA,EAAUhQ,QAC3B,OAAO,EAET,MAAM,OAAC5M,EAAM,MAAEiD,GAAS2Z,EAClBlX,EAASjC,EAAKhG,QAAQ2D,YAAc,EACpCiX,EAAK,CAACna,EAAG8B,EAAQ7B,EAAG8E,EAAQyC,GAC5B4S,EAAK,CAACpa,EAAG,EAAGC,EAAGuH,GACrB,OAAOjG,KAAKgZ,IAAID,GAAa,EAAGH,EAAIC,IAGtC,SAAS+B,GAAchT,EAAKwV,EAAQnX,EAAQkX,GAC1C,IAAKA,IAAcA,EAAUhQ,QAC3B,OAEF,MAAM,OAAC5M,EAAM,MAAEiD,EAAK,KAAE6G,EAAI,gBAAEN,EAAe,YAAEtB,GAAe0U,EACtDE,EAAerd,KAAKgZ,IAAIoE,EAAS7c,GAAU0F,EACjD2B,EAAIoC,YACJtB,EAAed,EAAKuV,GACpBrV,EAAeF,EAAKuV,GACpBvV,EAAIoE,OAAOqR,GAAe7Z,GAC1BoE,EAAIqE,OAAOmR,EAASnX,EAAQ,GAC5B2B,EAAIqE,OAAOoR,EAAc7Z,IACZ,IAAT6G,GACFzC,EAAIkC,UAAYC,GAAmBtB,EACnCb,EAAIwC,YACJxC,EAAIyC,OACJzC,EAAIe,YAAc,eAElBf,EAAIe,YAAcwU,EAAU7S,kBAE9B1C,EAAIiC,SAGN,SAASmR,GAAgBpX,EAAY5F,EAASqB,GAC5C,MAAM,EAACZ,EAAC,EAAEC,EAAC,GAAE+C,EAAE,GAAEC,EAAE,QAAEW,EAAO,QAAEC,GAAWsB,EACnC9D,EAAQE,KAAK0Z,MAAMhY,EAAKhD,EAAG+C,EAAKhD,GAChC6a,EAAKtU,EAAWhH,EAAQsf,aAAc,GACtCzd,EAAQ,CACZpB,EAAG4D,EAAUgC,EAAQhF,EAAUia,EAAG7a,GAAG,GACrCC,EAAG4D,EAAU+B,EAAQhF,EAAUia,EAAG5a,GAAG,IAEvC,OAAOkB,EAAQC,EAAO,CAACpB,EAAG4D,EAAS3D,EAAG4D,GAAUxC,GAGlD,SAASyd,GAAqB3V,GAAK,EAACnJ,EAAC,EAAEC,IAAI,MAACoB,EAAK,OAAEmG,GAASkX,GACrDA,GAAcA,EAAUhQ,UAG7BvF,EAAIgC,OACJhC,EAAID,UAAUlJ,EAAGC,GACjBkJ,EAAIC,OAAO/H,GACX8a,GAAchT,EAAK,GAAI3B,EAAQkX,GAC/BvV,EAAI2C,WAGN,SAAS+P,GAAU1S,EAAKrJ,EAAS+a,EAAI/Y,GACnC,MAAM,EAAC9B,EAAC,EAAEC,EAAC,GAAE+C,EAAE,GAAEC,EAAE,QAAE1D,GAAWO,GAC1B,UAACgc,EAAS,QAAEC,EAAO,YAAEC,EAAW,UAAEC,GAAaC,GAAcpc,GAC7Dqa,EAAK,CAACna,IAAGC,KACTma,EAAK,CAACpa,EAAGgD,EAAI/C,EAAGgD,GAChB8b,EAAa/D,GAAab,EAAIU,EAAIT,EAAI,GACtC4E,EAAWhE,GAAab,EAAIU,EAAIT,EAAI,GAAK,OACzC6E,EAAKnE,GAAaX,EAAIU,EAAIT,EAAI4B,EAAcla,GAC5Cod,EAAKpE,GAAaX,EAAIU,EAAIT,EAAI,EAAI6B,EAAYna,GAE9CqZ,EAAO,IAAIgE,OACjBhW,EAAIoC,YACJ4P,EAAK5N,OAAO0R,EAAGjf,EAAGif,EAAGhf,GACrBkb,EAAKiE,iBAAiBvE,EAAG7a,EAAG6a,EAAG5a,EAAGif,EAAGlf,EAAGkf,EAAGjf,GAC3CkJ,EAAIe,YAAc3K,EAAQsM,kBAC1B1C,EAAIiC,OAAO+P,GACXrb,EAAQqb,KAAOA,EACfrb,EAAQqJ,IAAMA,EACd2V,GAAqB3V,EAAK8V,EAAI,CAAC5d,MAAO0d,EAAYvX,OAAQwU,GAAcF,GACxEgD,GAAqB3V,EAAK+V,EAAI,CAAC7d,MAAO2d,EAAUxX,OAAQyU,GAAYF,GA/VtEb,GAAelE,SAAW,CACxBzB,kBAAkB,EAClBgJ,WAAY,CACV7P,SAAS,EACTpM,IAAKI,OAAO2c,OAAO,GAAI3C,IACvB9Q,MAAM,EACN9J,OAAQ,GACRO,MAAOK,OAAO2c,OAAO,GAAI3C,IACzB3X,MAAO,GAET0E,WAAY,GACZE,iBAAkB,EAClBkC,kBAAmB,cACnB3I,YAAa,EACb0Y,OAAO,EACPiD,aAAc,CACZ5e,EAAG,QAELyO,SAAS,EACToE,cAAUmE,EACVrP,UAAMqP,EACN9T,aAAc,EACdmC,MAAO,CACLgG,gBAAiB,kBACjBnB,sBAAuB,cACvBZ,eAAgB,OAChBS,YAAa,QACbP,WAAY,GACZE,iBAAkB,EAClBE,gBAAiB,QACjB6B,aAAc,EACdG,kBAAmB,cACnB3I,YAAa,EACbsL,QAAS9L,OAAO2c,OAAO,GAAIxF,GAAgB7C,SAASxI,SACpDjC,MAAO,OACPvD,QAAS,KACT0F,SAAS,EACTwI,cAAUD,EACVlQ,KAAM,CACJoQ,YAAQF,EACR7P,gBAAY6P,EACZvR,UAAMuR,EACN9K,WAAO8K,EACPG,OAAQ,QAEVpS,YAAQiS,EACR9T,kBAAc8T,EACd/K,aAAS+K,EACT7Q,QAAS,EACTT,SAAU,SACVnC,SAAU,EACV4G,WAAY,EACZC,cAAe,EACfC,cAAe,EACfvE,UAAW,SACX+G,qBAAiBmK,EACjBxM,gBAAiB,EACjB1F,WAAOkS,EACP/Q,QAAS,EACTC,QAAS,EACTkR,OAAGJ,GAELxG,aAASwG,EACT7M,WAAY,EACZC,cAAe,EACfC,cAAe,EACf1L,WAAOqY,EACPrF,UAAMqF,EACNtF,UAAMsF,EACNnH,cAAUmH,EACVlF,UAAMkF,EACNnF,UAAMmF,EACNhH,cAAUgH,EACVI,EAAG,GAGL6D,GAAe3D,YAAc,CAC3BgH,WAAY,CACVlc,MAAO,CACLmV,WAAW,GAEblV,IAAK,CACHkV,WAAW,GAEbA,WAAW,IAIf0D,GAAe5D,cAAgB,CAC7BtN,YAAa,SAyQf,MAAMsV,WAA0B,OAE9B,QAAQzI,EAAQC,EAAQrX,EAAMkE,GAC5B,MAAMH,EAAWuT,KAAKxX,QAAQiE,SACxBpB,GAAW2U,KAAKxX,QAAQ2D,YAAc6T,KAAKxX,QAAQ4D,cAAgB,EACzE,GAAa,MAAT1D,GAAyB,MAATA,EAClB,OAAO8f,GAAe,CAACvf,EAAG6W,EAAQ5W,EAAG6W,GAASC,KAAKjT,SAAS,CAAC,QAAS,SAAU,UAAW,WAAYH,GAAmBH,EAAUpB,GAEtI,MAAM,EAACpC,EAAC,EAAEC,EAAC,GAAE+C,EAAE,GAAEC,GAAM8T,KAAKjT,SAAS,CAAC,IAAK,IAAK,KAAM,MAAOH,GACvDxB,EAAiB,MAAT1C,EAAe,CAAC4C,MAAOpC,EAAGqC,IAAKW,GAAM,CAACZ,MAAOrC,EAAGsC,IAAKU,GAC7DoM,EAAejO,EAAQ,CAACnB,EAAG6W,EAAQ5W,EAAG6W,GAASC,KAAKrW,eAAeiD,GAAmB,gBAAWH,IACvG,OAAO4L,EAAa3P,IAAS0C,EAAME,MAAQD,EAAUL,GAAWqN,EAAa3P,IAAS0C,EAAMG,IAAMF,EAAUL,EAG9G,eAAe4B,GACb,OAAOD,EAAsBqT,KAAMpT,GAGrC,KAAKwF,GACH,MAAM,MAACpE,EAAK,OAAEC,EAAM,QAAEpB,EAAO,QAAEC,EAAO,QAAEtE,GAAWwX,KACnD5N,EAAIgC,OACJjC,EAAUC,EAAK4N,KAAKrW,iBAAkBnB,EAAQiE,UAC9CyG,EAAed,EAAK4N,KAAKxX,SACzB4J,EAAIoC,YACJpC,EAAIkC,UAAY9L,EAAQ+L,gBACxB,MAAMF,EAAS/B,EAAeF,EAAK5J,GACnC4J,EAAI9D,QAAQzB,EAASC,EAASmB,EAAS,EAAGD,EAAQ,EAAG,OAAK,EAAG,EAAG,EAAI,QACpEoE,EAAIyC,OACAR,IACFjC,EAAIe,YAAc3K,EAAQsM,kBAC1B1C,EAAIiC,UAENjC,EAAI2C,UAGN,YACE,OAAOiL,KAAKrE,UAAYqE,KAAKrE,SAAS,GAGxC,yBAAyBhL,EAAOnI,GAC9B,OAAOiT,GAA6B9K,EAAOnI,IA0C/C,SAASggB,GAAeC,EAAGna,EAAS7B,EAAUpB,GAC5C,MAAM,MAAC2C,EAAK,OAAEC,EAAM,QAAEpB,EAAO,QAAEC,GAAWwB,EACpCoa,EAAU1a,EAAQ,EAClB2a,EAAU1a,EAAS,EAEzB,GAAIya,GAAW,GAAKC,GAAW,EAC7B,OAAO,EAGT,MAAMre,EAAQ,eAAUmC,GAAY,GAC9Bmc,EAAWpe,KAAKD,IAAID,GACpBue,EAAWre,KAAKC,IAAIH,GACpBN,EAAIQ,KAAKuB,IAAI6c,GAAYH,EAAExf,EAAI4D,GAAWgc,GAAYJ,EAAEvf,EAAI4D,GAAU,GACtE7C,EAAIO,KAAKuB,IAAI8c,GAAYJ,EAAExf,EAAI4D,GAAW+b,GAAYH,EAAEvf,EAAI4D,GAAU,GAC5E,OAAQ9C,EAAIQ,KAAKuB,IAAI2c,EAAUrd,EAAS,GAAOpB,EAAIO,KAAKuB,IAAI4c,EAAUtd,EAAS,IAAO,OAnDxFkd,GAAkBzO,GAAK,oBAEvByO,GAAkBtI,SAAW,CAC3BzB,kBAAkB,EAClBpL,sBAAuB,cACvBV,WAAY,GACZE,iBAAkB,EAClBkC,kBAAmB,cACnB3I,YAAa,EACbwL,SAAS,EACTvL,aAAc,EACdyE,UAAMqP,EACN3R,MAAO5C,OAAO2c,OAAO,GAAIzI,GAAcI,SAAS1R,OAChD9B,SAAU,EACV4G,WAAY,EACZC,cAAe,EACfC,cAAe,EACfsH,UAAMqF,EACNtF,UAAMsF,EACNnH,cAAUmH,EACVlF,UAAMkF,EACNnF,UAAMmF,EACNhH,cAAUgH,EACVI,EAAG,GAGLiI,GAAkBhI,cAAgB,CAChCtN,YAAa,QACbsB,gBAAiB,SAGnBgU,GAAkB/H,YAAc,CAC9BjS,MAAO,CACLkS,WAAW,IAqBf,MAAMqI,WAAwB,OAE5B,QAAQhJ,EAAQC,EAAQrX,EAAMkE,GAC5B,MAAM,EAAC3D,EAAC,EAAEC,EAAC,GAAE+C,EAAE,GAAEC,EAAE,MAAE8B,GAASgS,KAAKjT,SAAS,CAAC,IAAK,IAAK,KAAM,KAAM,SAAUH,GACvEvB,GAAW2U,KAAKxX,QAAQ2D,YAAc6T,KAAKxX,QAAQ4D,cAAgB,EACzE,GAAa,MAAT1D,GAAyB,MAATA,EAClB,OAAOmD,EAAa,CAAC5C,EAAG6W,EAAQ5W,EAAG6W,GAASC,KAAKrW,eAAeiD,GAAmBoB,EAAQ,EAAG3C,GAEhG,MAAMD,EAAiB,MAAT1C,EAAe,CAAC4C,MAAOpC,EAAGqC,IAAKW,EAAIrE,MAAOkY,GAAU,CAACzU,MAAOrC,EAAGsC,IAAKU,EAAIpE,MAAOiY,GAC7F,OAAO3U,EAAQC,EAAOC,GAGxB,eAAeuB,GACb,OAAOD,EAAsBqT,KAAMpT,GAGrC,KAAKwF,GACH,MAAM5J,EAAUwX,KAAKxX,QACf2D,EAAc3D,EAAQ2D,YAC5B,GAAI3D,EAAQsD,OAAS,GACnB,OAEFsG,EAAIgC,OACJhC,EAAIkC,UAAY9L,EAAQ+L,gBACxBrB,EAAed,EAAK5J,GACpB,MAAM6L,EAAS/B,EAAeF,EAAK5J,GACnCwN,EAAU5D,EAAK4N,KAAMA,KAAKnT,QAASmT,KAAKlT,SACpCuH,IAAWrC,EAAgBxJ,EAAQyN,cACrC7D,EAAIe,YAAc3K,EAAQsM,kBAC1B1C,EAAIiC,UAENjC,EAAI2C,UACJvM,EAAQ2D,YAAcA,EAGxB,yBAAyBwE,EAAOnI,GAC9B,MAAM4F,EAAa6M,GAAuBtK,EAAOnI,GAEjD,OADA4F,EAAWsN,eAAiBhL,EAAwBC,EAAOvC,EAAY5F,GAChE4F,GAIX0a,GAAgBhP,GAAK,kBAErBgP,GAAgB7I,SAAW,CACzBzB,kBAAkB,EAClBpL,sBAAuB,cACvBV,WAAY,GACZE,iBAAkB,EAClBkC,kBAAmB,cACnB3I,YAAa,EACbwL,SAAS,EACTvL,aAAc,EACdyE,UAAMqP,EACNjK,WAAY,SACZnK,OAAQ,GACRW,SAAU,EACV4G,WAAY,EACZC,cAAe,EACfC,cAAe,EACfpE,QAAS,EACT0L,UAAMqF,EACNtF,UAAMsF,EACNnH,cAAUmH,EACV3P,YAAQ2P,EACR9Q,QAAS,EACT4L,UAAMkF,EACNnF,UAAMmF,EACNhH,cAAUgH,EACV1P,YAAQ0P,EACRI,EAAG,GAGLwI,GAAgBvI,cAAgB,CAC9BtN,YAAa,QACbsB,gBAAiB,SAGnB,MAAMwU,WAA0B,OAE9B,QAAQjJ,EAAQC,EAAQrX,EAAMkE,GAC5B,GAAa,MAATlE,GAAyB,MAATA,EAClB,OAAOsX,KAAKxX,QAAQsD,QAAU,IAAOkU,KAAKrE,SAAS5Q,OAAS,GAAKie,GAAiBhJ,KAAKrE,SAAUmE,EAAQC,EAAQnT,GAEnH,MAAMyL,EAAejO,EAAQ,CAACnB,EAAG6W,EAAQ5W,EAAG6W,GAASC,KAAKrW,eAAeiD,GAAmB,gBAAWoT,KAAKxX,QAAQiE,WAC9Gwc,EAAajJ,KAAKrE,SAASzL,IAAK7F,GAAmB,MAAT3B,EAAe2B,EAAM6e,GAAK7e,EAAM8e,IAC1E7d,EAAQd,KAAK1C,OAAOmhB,GACpB1d,EAAMf,KAAKzC,OAAOkhB,GACxB,OAAO5Q,EAAa3P,IAAS4C,GAAS+M,EAAa3P,IAAS6C,EAG9D,eAAeqB,GACb,OAAOD,EAAsBqT,KAAMpT,GAGrC,KAAKwF,GACH,MAAM,SAACuJ,EAAQ,QAAEnT,GAAWwX,KAC5B5N,EAAIgC,OACJhC,EAAIoC,YACJpC,EAAIkC,UAAY9L,EAAQ+L,gBACxBrB,EAAed,EAAK5J,GACpB,MAAM6L,EAAS/B,EAAeF,EAAK5J,GACnC,IAAI4gB,GAAQ,EACZ,IAAK,MAAMC,KAAM1N,EACXyN,GACFhX,EAAIoE,OAAO6S,EAAGpgB,EAAGogB,EAAGngB,GACpBkgB,GAAQ,GAERhX,EAAIqE,OAAO4S,EAAGpgB,EAAGogB,EAAGngB,GAGxBkJ,EAAIwC,YACJxC,EAAIyC,OAEAR,IACFjC,EAAIe,YAAc3K,EAAQsM,kBAC1B1C,EAAIiC,UAENjC,EAAI2C,UAGN,yBAAyBpE,EAAOnI,GAC9B,MAAM4F,EAAa6M,GAAuBtK,EAAOnI,IAC3C,MAAC8gB,EAAK,SAAE7c,GAAYjE,EACpBmT,EAAW,GACXrR,EAAS,EAAI,OAAMgf,EACzB,IAAIpT,EAAMzJ,EAAW,OACrB,IAAK,IAAIa,EAAI,EAAGA,EAAIgc,EAAOhc,IAAK4I,GAAO5L,EAAO,CAC5C,MAAMif,EAAUC,GAAkBpb,EAAY5F,EAAS0N,GACvDqT,EAAQ7N,eAAiBhL,EAAwBC,EAAOvC,EAAY5F,GACpEmT,EAAS7R,KAAKyf,GAGhB,OADAnb,EAAWuN,SAAWA,EACfvN,GA6CX,SAASob,IAAkB,QAAC3c,EAAO,QAAEC,IAAU,OAAChB,EAAM,YAAEK,EAAW,aAAEC,GAAe8J,GAClF,MAAM7K,GAAWc,EAAcC,GAAgB,EACzC3B,EAAMD,KAAKC,IAAIyL,GACf3L,EAAMC,KAAKD,IAAI2L,GACf7L,EAAQ,CAACpB,EAAG4D,EAAUpC,EAAMqB,EAAQ5C,EAAG4D,EAAUvC,EAAMuB,GAC7D,MAAO,CACLwF,KAAM,QACNsK,YAAa,QACbxN,WAAY,CACVnF,EAAGoB,EAAMpB,EACTC,EAAGmB,EAAMnB,EACT2D,QAASxC,EAAMpB,EACf6D,QAASzC,EAAMnB,EACfigB,GAAItc,EAAUpC,GAAOqB,EAAST,GAC9B6d,GAAIpc,EAAUvC,GAAOuB,EAAST,KAKpC,SAAS2d,GAAiBS,EAAQxgB,EAAGC,EAAG0D,GACtC,IAAI8c,GAAW,EACXC,EAAIF,EAAOA,EAAO1e,OAAS,GAAGgC,SAAS,CAAC,KAAM,MAAOH,GACzD,IAAK,MAAMvC,KAASof,EAAQ,CAC1B,MAAMG,EAAIvf,EAAM0C,SAAS,CAAC,KAAM,MAAOH,GAClCgd,EAAEV,GAAKhgB,IAAQygB,EAAET,GAAKhgB,GAAMD,GAAK0gB,EAAER,GAAKS,EAAET,KAAOjgB,EAAI0gB,EAAEV,KAAOS,EAAET,GAAKU,EAAEV,IAAMU,EAAET,KAClFO,GAAYA,GAEdC,EAAIC,EAEN,OAAOF,EAtETX,GAAkBjP,GAAK,oBAEvBiP,GAAkB9I,SAAW,CAC3BzB,kBAAkB,EAClBpL,sBAAuB,cACvBZ,eAAgB,OAChBE,WAAY,GACZE,iBAAkB,EAClBE,gBAAiB,QACjBgC,kBAAmB,cACnB3I,YAAa,EACbwL,SAAS,EACTvL,aAAc,EACdyE,UAAMqP,EACN7V,MAAO,CACLyB,OAAQ,GAEVA,OAAQ,GACRW,SAAU,EACV4G,WAAY,EACZC,cAAe,EACfC,cAAe,EACf+V,MAAO,EACPna,QAAS,EACT0L,UAAMqF,EACNtF,UAAMsF,EACNnH,cAAUmH,EACV3P,YAAQ2P,EACR9Q,QAAS,EACT4L,UAAMkF,EACNnF,UAAMmF,EACNhH,cAAUgH,EACV1P,YAAQ0P,EACRI,EAAG,GAGLyI,GAAkBxI,cAAgB,CAChCtN,YAAa,QACbsB,gBAAiB,SAmCnB,MAAMsV,GAAkB,CACtB1b,IAAK0R,GACLxR,cAAeqS,GACfpS,QAASia,GACTha,MAAOuU,GACPtU,KAAM2V,GACN9Z,MAAOye,GACPra,QAASsa,IAWXpd,OAAOC,KAAKie,IAAiBzY,QAAQ1F,IACnC,QAASoe,SAAS,YAAYD,GAAgBne,GAAKoO,GAAM,CACvD2G,UAAW,gCAIf,MAAMsJ,GAAgB,CACpBC,OAAQre,OAAO2c,QAGX2B,GAAUrN,GAAWC,OAAOsB,IAC5B+L,GAAU,CAACriB,EAAOsiB,IAAY,eAASA,GAAWC,GAAWviB,EAAOsiB,GAAWtiB,EAa/EwiB,GAAe/K,GAAkB,UAATA,GAA6B,SAATA,EAOlD,SAASgL,GAAYhZ,EAAO,QAC1B,OAAIuY,GAAgBvY,GACXA,GAET8N,QAAQC,KAAK,6BAA6B/N,4BACnC,QAST,SAASiZ,GAAe5Z,EAAOoM,EAAOvU,EAASI,GAC7C,MAAM4hB,EAAaC,GAAkB9Z,EAAOnI,EAAQgiB,WAAY5hB,GAE1DuU,EAAcJ,EAAMI,YACpBxB,EAAW+O,GAAe3N,EAAMpB,SAAUwB,GAEhD,IAAK,IAAI7P,EAAI,EAAGA,EAAI6P,EAAYpS,OAAQuC,IAAK,CAC3C,MAAMqd,EAAoBxN,EAAY7P,GAChCvE,EAAU6hB,GAAmBjP,EAAUrO,EAAGqd,EAAkBrZ,MAC5DuZ,EAAWF,EAAkBG,WAAWC,GAAWpa,EAAO5H,EAAS4S,EAAUgP,IAC7Evc,EAAarF,EAAQiiB,yBAAyBra,EAAOka,GAE3Dzc,EAAW6c,KAAOC,GAAO9c,GAErB,aAAcA,IAChB+c,GAAkBpiB,EAASqF,EAAWuN,SAAUkP,EAAUL,UAGnDpc,EAAWuN,UAGf,eAAQ5S,EAAQE,IAKnB0C,OAAO2c,OAAOvf,EAASqF,GAGzBzC,OAAO2c,OAAOvf,EAASqF,EAAWsN,gBAClCtN,EAAW5F,QAAU4iB,GAAyBP,GAE9CL,EAAWR,OAAOjhB,EAASqF,IAI/B,SAAS8c,GAAO9c,GACd,OAAOuD,MAAMvD,EAAWnF,IAAM0I,MAAMvD,EAAWlF,GAGjD,SAASuhB,GAAkB9Z,EAAO0a,EAAUziB,GAC1C,MAAa,UAATA,GAA6B,SAATA,GAA4B,WAATA,EAClCmhB,GAEF,IAAI,OAAWpZ,EAAO0a,GAG/B,SAASF,GAAkBG,EAAa3P,EAAUkP,EAAUL,GAC1D,MAAMe,EAAcD,EAAY3P,WAAa2P,EAAY3P,SAAW,IACpE4P,EAAYxgB,OAAS4Q,EAAS5Q,OAC9B,IAAK,IAAIuC,EAAI,EAAGA,EAAIqO,EAAS5Q,OAAQuC,IAAK,CACxC,MAAMke,EAAa7P,EAASrO,GACtBc,EAAaod,EAAWpd,WACxBqd,EAAab,GAAmBW,EAAaje,EAAGke,EAAWla,KAAMka,EAAW9P,gBAC5EgQ,EAAcb,EAASW,EAAW5P,aAAa+P,SAASH,GAC9Dpd,EAAW5F,QAAU4iB,GAAyBM,GAC9ClB,EAAWR,OAAOyB,EAAYrd,IAIlC,SAASwc,GAAmBjP,EAAU9C,EAAOvH,EAAMoK,GACjD,MAAMkQ,EAAe/B,GAAgBS,GAAYhZ,IACjD,IAAIvI,EAAU4S,EAAS9C,GAKvB,OAJK9P,GAAaA,aAAmB6iB,IACnC7iB,EAAU4S,EAAS9C,GAAS,IAAI+S,EAChCjgB,OAAO2c,OAAOvf,EAAS2S,IAElB3S,EAGT,SAASqiB,GAAyBP,GAChC,MAAMe,EAAe/B,GAAgBS,GAAYO,EAASvZ,OACpDC,EAAS,GACfA,EAAOuI,GAAK+Q,EAAS/Q,GACrBvI,EAAOD,KAAOuZ,EAASvZ,KACvBC,EAAO4O,SAAW0K,EAAS1K,SAC3BxU,OAAO2c,OAAO/W,EACZ6Y,GAAWS,EAAUe,EAAa3L,UAClCmK,GAAWS,EAAUe,EAAarL,gBACpC,IAAK,MAAMlP,KAAQ4Y,GACjB1Y,EAAOF,GAAQwZ,EAASxZ,GAE1B,OAAOE,EAGT,SAAS6Y,GAAWS,EAAUgB,GAC5B,MAAMta,EAAS,GACf,IAAK,MAAM+N,KAAQ3T,OAAOC,KAAKigB,GAAO,CACpC,MAAM1B,EAAU0B,EAAKvM,GACfzX,EAAQgjB,EAASvL,GACnB+K,GAAY/K,IAAS,eAAQzX,GAC/B0J,EAAO+N,GAAQzX,EAAMqI,IAAK4B,GAASoY,GAAQpY,EAAMqY,IAEjD5Y,EAAO+N,GAAQ4K,GAAQriB,EAAOsiB,GAGlC,OAAO5Y,EAGT,SAASwZ,GAAWpa,EAAO5H,EAAS4S,EAAUmD,GAC5C,OAAO/V,EAAQmV,WAAanV,EAAQmV,SAAWvS,OAAO2c,OAAO3c,OAAOmgB,OAAOnb,EAAMoa,cAAe,CAC9FhiB,UACA,eACE,OAAO4S,EAAStS,OAAQggB,GAAOA,GAAMA,EAAG7gB,UAE1CsR,GAAIgF,EAAWhF,GACfxI,KAAM,gBAIV,SAASoZ,GAAe/O,EAAUwB,GAChC,MAAMxG,EAAQwG,EAAYpS,OACpBO,EAAQqQ,EAAS5Q,OAEvB,GAAIO,EAAQqL,EAAO,CACjB,MAAMoV,EAAMpV,EAAQrL,EACpBqQ,EAASqQ,OAAO1gB,EAAO,KAAM,IAAI2gB,MAAMF,SAC9BzgB,EAAQqL,GACjBgF,EAASqQ,OAAOrV,EAAOrL,EAAQqL,GAEjC,OAAOgF,EAGT,IAAIuQ,GAAU,QAEd,MAAMC,GAAc,IAAI1a,IAClB2a,GAAqBtN,GAAkC,kBAApBA,EAAWxN,KAC9CL,GAAQ2L,GAAWC,OAAOsB,IAEhC,IAAIW,GAAa,CACfhF,GAAI,aAEJoS,WAEA,iBACElf,EAAe,WAAY,MAAO,OAAMkf,UAG1C,gBACE,OAAMG,SAASxC,KAGjB,kBACE,OAAMyC,WAAWzC,KAGnB,WAAWlZ,GACTwb,GAAYnY,IAAIrD,EAAO,CACrBwM,YAAa,GACbxB,SAAU,GACVvT,gBAAiB,GACjB6U,UAAW,GACXD,UAAU,EACVE,cAAc,EACdjM,MAAO,GACPoN,QAAQ,EACRX,QAAS,MAIb,aAAa/M,EAAO4b,EAAM/jB,GACxB,MAAMuU,EAAQoP,GAAYjY,IAAIvD,GACxBwM,EAAcJ,EAAMI,YAAc,GAExC,IAAIwN,EAAoBniB,EAAQ2U,YAC5B,eAASwN,GACXhf,OAAOC,KAAK+e,GAAmBvZ,QAAQ1F,IACrC,MAAM7D,EAAQ8iB,EAAkBjf,GAC5B,eAAS7D,KACXA,EAAMiS,GAAKpO,EACXyR,EAAYrT,KAAKjC,MAGZ,eAAQ8iB,IACjBxN,EAAYrT,QAAQ6gB,GAEtB9L,GAAmB1B,EAAY9T,OAAO+iB,IAAqBzb,EAAM8I,SAGnE,gBAAgB9I,EAAO4b,GACrB,MAAMxP,EAAQoP,GAAYjY,IAAIvD,GAC9B6N,GAAiB7N,EAAO4b,EAAKnT,MAAO2D,EAAMI,YAAY9T,OAAO+iB,IAAoB/iB,OAAOW,GAAKA,EAAE2N,SAAW3N,EAAEwU,oBAG9G,YAAY7N,EAAO4b,EAAM/jB,GACvB,MAAMuU,EAAQoP,GAAYjY,IAAIvD,GAC9BmM,GAAgBnM,EAAOoM,EAAOvU,GAC9B+hB,GAAe5Z,EAAOoM,EAAOvU,EAAS+jB,EAAK3jB,MAC3CmU,EAAM3U,gBAAkB2U,EAAMpB,SAAStS,OAAOggB,IAAOA,EAAG4B,MAAQ5B,EAAG7gB,QAAQmP,SAC3EyG,GAAYzN,EAAOoM,EAAOvU,IAG5B,mBAAmBmI,EAAO6b,EAAOhkB,GAC/BikB,GAAK9b,EAAO,qBAAsBnI,EAAQkkB,OAG5C,kBAAkB/b,EAAO6b,EAAOhkB,GAC9BikB,GAAK9b,EAAO,oBAAqBnI,EAAQkkB,OAG3C,kBAAkB/b,EAAO6b,EAAOhkB,GAC9BikB,GAAK9b,EAAO6b,EAAM3T,MAAOrQ,EAAQkkB,OAGnC,WAAW/b,EAAO6b,EAAOhkB,GACvBikB,GAAK9b,EAAO,aAAcnI,EAAQkkB,OAGpC,UAAU/b,EAAO6b,EAAOhkB,GACtBikB,GAAK9b,EAAO,YAAanI,EAAQkkB,OAGnC,YAAY/b,EAAO4b,EAAM/jB,GACvB,MAAMuU,EAAQoP,GAAYjY,IAAIvD,GAC1B2M,GAAYP,EAAOwP,EAAKlkB,MAAOG,KACjC+jB,EAAK3O,SAAU,IAInB,aAAajN,GACXwb,GAAYQ,OAAOhc,IAGrB,eAAeA,GACb,MAAMoM,EAAQoP,GAAYjY,IAAIvD,GAC9B,OAAOoM,EAAQA,EAAMpB,SAAW,IAIlC,qCAAqCvT,EAAiBC,EAAOG,GAC3D,OAAOG,EAAYP,EAAiBC,EAAOG,IAG7CyX,SAAU,CACRuK,WAAY,CACVoC,QAAS,CACPxe,WAAY,CAAC,IAAK,IAAK,KAAM,KAAM,QAAS,SAAU,UAAW,UAAW,SAAU,SAAU,UAChGkD,KAAM,UAERmE,OAAQ,CACNrH,WAAY,CAAC,kBAAmB,eAChCkD,KAAM,UAGVob,MAAM,EACNxkB,YAAa,CACXU,UAAMsX,EACNxX,UAAMwX,EACN3X,eAAW2X,GAEb2M,OAAQ,CACN1M,SAAU,oBACVtP,MAAM,EACNtC,MAAO,KAKXiS,YAAa,CACXsM,YAAY,EACZC,YAAczN,IAAUrO,GAAMwH,SAAS6G,IAAkB,SAATA,EAChDnC,YAAa,CACX6P,UAAU,EACVvM,UAAW,CAACnB,EAAM2N,IAAS,YAAYpD,GAAgBS,GAAY2C,EAAK3b,OAAOwI,IAEjF5R,YAAa,CACXuY,WAAW,GAEboM,OAAQ,CACNte,MAAO,CACLue,WAAYzC,GACZ5J,WAAW,GAEbqM,WAAYzC,KAIhB6C,uBAAwB,CAAC,KAG3B,SAAST,GAAK9b,EAAOwc,EAAQT,GAC3B,MAAM,IAACta,EAAG,UAAE8H,GAAavJ,EACnBoM,EAAQoP,GAAYjY,IAAIvD,GAE1B+b,GACF,eAASta,EAAK8H,GAGhB,MAAMkT,EAAmBC,GAAoBtQ,EAAM3U,gBAAiB+kB,GAAQpjB,KAAK,CAACC,EAAGC,IAAMD,EAAEjB,QAAQP,QAAQ8X,EAAIrW,EAAElB,QAAQP,QAAQ8X,GACnI,IAAK,MAAMxO,KAAQsb,EACjBE,GAAYlb,EAAK8H,EAAW6C,EAAOjL,GAGjC4a,GACF,eAAWta,GAIf,SAASib,GAAoB1R,EAAUwR,GACrC,MAAMC,EAAmB,GACzB,IAAK,MAAM/D,KAAM1N,EAIf,GAHI0N,EAAG7gB,QAAQ2X,WAAagN,GAC1BC,EAAiBtjB,KAAK,CAACf,QAASsgB,EAAIkE,MAAM,IAExClE,EAAG1N,UAAY0N,EAAG1N,SAAS5Q,OAC7B,IAAK,MAAMyiB,KAAOnE,EAAG1N,SACf6R,EAAIhlB,QAAQmP,SAAW6V,EAAIhlB,QAAQ2X,WAAagN,GAClDC,EAAiBtjB,KAAK,CAACf,QAASykB,IAKxC,OAAOJ,EAGT,SAASE,GAAYlb,EAAK8H,EAAW6C,EAAOjL,GAC1C,MAAMuX,EAAKvX,EAAK/I,QACZ+I,EAAKyb,MACPjP,GAAWvB,EAAOsM,EAAI,cACtBA,EAAGoD,KAAKra,EAAK8H,GACboE,GAAWvB,EAAOsM,EAAI,cAEtBA,EAAGoD,KAAKra,EAAK8H,K,kCCp9FjB,0EASIuT,EAAoB,WACtB,GAAsB,qBAAXC,OAAwB,CACjC,GAAIA,OAAOD,iBACT,OAAOC,OAAOD,iBAMhB,IAAIE,EAASD,OAAOC,OACpB,GAAIA,EACF,OAAQA,EAAOC,YAAc,IAAMD,EAAOE,aAAe,GAI7D,OAAO,EAfc,GAkBnBC,EAAQ,CAEVC,YAAa,SAASC,GACpB,IACIC,EADAta,EAAQ,GAGZqa,EAAS,GAAGnR,OAAOmR,GACnB,MAAOA,EAAOjjB,OACZkjB,EAAQD,EAAOE,MACM,kBAAVD,EACTta,EAAMwa,QAAQC,MAAMza,EAAOsa,EAAM5gB,MAAM,OAC9B4e,MAAMoC,QAAQJ,GACvBD,EAAOlkB,KAAKskB,MAAMJ,EAAQC,GAChB,eAAcD,IACxBra,EAAMwa,QAAQ,GAAKF,GAIvB,OAAOta,GAKTyS,SAAU,SAAShU,EAAKuB,EAAO3D,GAC7B,IAII1C,EAJAghB,EAAQ,GAAGzR,OAAOlJ,GAClB4a,EAAOD,EAAMvjB,OACb8G,EAAOO,EAAIpC,KACXhC,EAAQ,EAKZ,IAFAoE,EAAIpC,KAAOA,EAAK+B,OAEXzE,EAAI,EAAGA,EAAIihB,IAAQjhB,EACtBU,EAAQxD,KAAKzC,IAAIqK,EAAIyE,YAAYyX,EAAMhhB,IAAIU,MAAOA,GAKpD,OAFAoE,EAAIpC,KAAO6B,EAEJ,CACL5D,OAAQsgB,EAAOve,EAAKK,WACpBrC,MAAOA,IASXwgB,MAAO,SAAS1mB,EAAKD,EAAOE,GAC1B,OAAOyC,KAAKzC,IAAID,EAAK0C,KAAK1C,IAAID,EAAOE,KAQvC0mB,UAAW,SAASC,EAAIC,GACtB,IAEIrhB,EAAGshB,EAAGL,EAAM5K,EAFZ9R,EAAO6c,EAAGvkB,QACV0kB,EAAU,GAGd,IAAKvhB,EAAI,EAAGihB,EAAOI,EAAG5jB,OAAQuC,EAAIihB,IAAQjhB,EACxCqW,EAAIgL,EAAGrhB,GACPshB,EAAI/c,EAAKkM,QAAQ4F,IAEN,IAAPiL,EACFC,EAAQ/kB,KAAK,CAAC6Z,EAAG,IAEjB9R,EAAKma,OAAO4C,EAAG,GAInB,IAAKthB,EAAI,EAAGihB,EAAO1c,EAAK9G,OAAQuC,EAAIihB,IAAQjhB,EAC1CuhB,EAAQ/kB,KAAK,CAAC+H,EAAKvE,IAAK,IAG1B,OAAOuhB,GAMTC,UAAW,SAASnL,GAClB,OAAOnZ,KAAKukB,MAAMpL,EAAI8J,GAAoBA,IAI9C,SAASuB,EAAO3kB,EAAO4kB,GACrB,IAAIC,EAAKD,EAAOhmB,EACZkmB,EAAKF,EAAO/lB,EAEhB,GAAW,OAAPgmB,EACF,MAAO,CAACjmB,EAAG,EAAGC,GAAI,GAEpB,GAAW,OAAPimB,EACF,MAAO,CAAClmB,EAAG,EAAGC,EAAG,GAGnB,IAAI6c,EAAK1b,EAAMpB,EAAIimB,EACflJ,EAAK3b,EAAMnB,EAAIimB,EACfC,EAAK5kB,KAAKgY,KAAKuD,EAAKA,EAAKC,EAAKA,GAElC,MAAO,CACL/c,EAAGmmB,EAAKrJ,EAAKqJ,EAAK,EAClBlmB,EAAGkmB,EAAKpJ,EAAKoJ,GAAM,GAIvB,SAASC,EAAQpmB,EAAGC,EAAGomB,EAAIC,EAAIC,GAC7B,OAAQA,GACR,IAAK,SACHF,EAAKC,EAAK,EACV,MACF,IAAK,SACHD,EAAK,EACLC,EAAK,EACL,MACF,IAAK,QACHD,EAAK,EACLC,EAAK,EACL,MACF,IAAK,OACHD,GAAM,EACNC,EAAK,EACL,MACF,IAAK,MACHD,EAAK,EACLC,GAAM,EACN,MACF,IAAK,QACHD,GAAMA,EACNC,GAAMA,EACN,MACF,IAAK,MAEH,MACF,QAEEC,GAAUhlB,KAAKilB,GAAK,IACpBH,EAAK9kB,KAAKD,IAAIilB,GACdD,EAAK/kB,KAAKC,IAAI+kB,GACd,MAGF,MAAO,CACLvmB,EAAGA,EACHC,EAAGA,EACHomB,GAAIA,EACJC,GAAIA,GAOR,IAAIG,EAAW,EACXC,EAAS,EACTC,EAAU,EACVC,EAAW,EACXC,EAAQ,EAEZ,SAASC,EAAO9mB,EAAGC,EAAGsD,GACpB,IAAIwjB,EAAMN,EAaV,OAXIzmB,EAAIuD,EAAK6N,KACX2V,GAAOL,EACE1mB,EAAIuD,EAAKgO,QAClBwV,GAAOJ,GAEL1mB,EAAIsD,EAAK8N,IACX0V,GAAOF,EACE5mB,EAAIsD,EAAKiO,SAClBuV,GAAOH,GAGFG,EAGT,SAASC,EAAQC,EAAS5U,GACxB,IAMI6L,EAAGle,EAAGC,EANNgmB,EAAKgB,EAAQhB,GACbC,EAAKe,EAAQf,GACbtJ,EAAKqK,EAAQrK,GACbC,EAAKoK,EAAQpK,GACbqK,EAAKJ,EAAOb,EAAIC,EAAI7T,GACpB8U,EAAKL,EAAOlK,EAAIC,EAAIxK,GAIxB,MAAO,EAAM,CACX,KAAM6U,EAAKC,IAAQD,EAAKC,EAEtB,MAIFjJ,EAAIgJ,GAAMC,EAENjJ,EAAI2I,GACN7mB,EAAIimB,GAAMrJ,EAAKqJ,IAAO5T,EAAKhB,IAAM6U,IAAOrJ,EAAKqJ,GAC7CjmB,EAAIoS,EAAKhB,KACA6M,EAAI0I,GACb5mB,EAAIimB,GAAMrJ,EAAKqJ,IAAO5T,EAAKb,OAAS0U,IAAOrJ,EAAKqJ,GAChDjmB,EAAIoS,EAAKb,QACA0M,EAAIyI,GACb1mB,EAAIimB,GAAMrJ,EAAKqJ,IAAO7T,EAAKd,MAAQ0U,IAAOrJ,EAAKqJ,GAC/CjmB,EAAIqS,EAAKd,OACA2M,EAAIwI,IACbzmB,EAAIimB,GAAMrJ,EAAKqJ,IAAO7T,EAAKjB,KAAO6U,IAAOrJ,EAAKqJ,GAC9CjmB,EAAIqS,EAAKjB,MAGP8M,IAAMgJ,GACRjB,EAAKjmB,EACLkmB,EAAKjmB,EACLinB,EAAKJ,EAAOb,EAAIC,EAAI7T,KAEpBuK,EAAK5c,EACL6c,EAAK5c,EACLknB,EAAKL,EAAOlK,EAAIC,EAAIxK,IAIxB,MAAO,CACL4T,GAAIA,EACJrJ,GAAIA,EACJsJ,GAAIA,EACJrJ,GAAIA,GAIR,SAASuK,EAAU5R,EAAO6R,GACxB,IAEIrnB,EAAGC,EAFHqnB,EAASD,EAAOC,OAChBL,EAAUzR,EAkBd,OAfI6R,EAAO1oB,QACTsoB,EAAUD,EAAQC,EAASI,EAAOhV,OAGrB,UAAXiV,GACFtnB,EAAIinB,EAAQhB,GACZhmB,EAAIgnB,EAAQf,IACQ,QAAXoB,GACTtnB,EAAIinB,EAAQrK,GACZ3c,EAAIgnB,EAAQpK,KAEZ7c,GAAKinB,EAAQhB,GAAKgB,EAAQrK,IAAM,EAChC3c,GAAKgnB,EAAQf,GAAKe,EAAQpK,IAAM,GAG3BuJ,EAAQpmB,EAAGC,EAAGuV,EAAM6Q,GAAI7Q,EAAM8Q,GAAIe,EAAOd,OAGlD,IAAIgB,EAAc,CAChBja,IAAK,SAAS8S,EAAIiH,GAChB,IAAIhmB,GAAS+e,EAAGrB,WAAaqB,EAAGpB,UAAY,EACxCqH,EAAK9kB,KAAKD,IAAID,GACdilB,EAAK/kB,KAAKC,IAAIH,GACd6lB,EAAK9G,EAAG9H,YACR6O,EAAK/G,EAAGoH,YAEZ,OAAOJ,EAAU,CACfnB,GAAI7F,EAAGpgB,EAAIqmB,EAAKa,EAChBhB,GAAI9F,EAAGngB,EAAIqmB,EAAKY,EAChBtK,GAAIwD,EAAGpgB,EAAIqmB,EAAKc,EAChBtK,GAAIuD,EAAGngB,EAAIqmB,EAAKa,EAChBd,GAAIA,EACJC,GAAIA,GACHe,IAGLjmB,MAAO,SAASgf,EAAIiH,GAClB,IAAI3M,EAAIqL,EAAO3F,EAAIiH,EAAOrB,QACtByB,EAAK/M,EAAE1a,EAAIogB,EAAG7gB,QAAQsD,OACtB6kB,EAAKhN,EAAEza,EAAImgB,EAAG7gB,QAAQsD,OAE1B,OAAOukB,EAAU,CACfnB,GAAI7F,EAAGpgB,EAAIynB,EACXvB,GAAI9F,EAAGngB,EAAIynB,EACX9K,GAAIwD,EAAGpgB,EAAIynB,EACX5K,GAAIuD,EAAGngB,EAAIynB,EACXrB,GAAI3L,EAAE1a,EACNsmB,GAAI5L,EAAEza,GACLonB,IAGLM,IAAK,SAASvH,EAAIiH,GAChB,IAAI3M,EAAIqL,EAAO3F,EAAIiH,EAAOrB,QACtBhmB,EAAIogB,EAAGpgB,EACPC,EAAImgB,EAAGngB,EACP2nB,EAAK,EACLC,EAAK,EAUT,OARIzH,EAAG0H,YACL9nB,EAAIuB,KAAK1C,IAAIuhB,EAAGpgB,EAAGogB,EAAG2H,MACtBH,EAAKrmB,KAAKgZ,IAAI6F,EAAG2H,KAAO3H,EAAGpgB,KAE3BC,EAAIsB,KAAK1C,IAAIuhB,EAAGngB,EAAGmgB,EAAG2H,MACtBF,EAAKtmB,KAAKgZ,IAAI6F,EAAG2H,KAAO3H,EAAGngB,IAGtBmnB,EAAU,CACfnB,GAAIjmB,EACJkmB,GAAIjmB,EAAI4nB,EACRjL,GAAI5c,EAAI4nB,EACR/K,GAAI5c,EACJomB,GAAI3L,EAAE1a,EACNsmB,GAAI5L,EAAEza,GACLonB,IAGLjX,SAAU,SAASgQ,EAAIiH,GACrB,IAAI3M,EAAIqL,EAAO3F,EAAIiH,EAAOrB,QAE1B,OAAOoB,EAAU,CACfnB,GAAI7F,EAAGpgB,EACPkmB,GAAI9F,EAAGngB,EACP2c,GAAIwD,EAAGpgB,GAAKogB,EAAGrb,OAAS,GACxB8X,GAAIuD,EAAGngB,GAAKmgB,EAAGpb,QAAU,GACzBqhB,GAAI3L,EAAE1a,EACNsmB,GAAI5L,EAAEza,GACLonB,KAIHxB,EAAYhB,EAAMgB,UAEtB,SAASmC,EAAcC,GACrB,IAAI/kB,EAAc+kB,EAAM/kB,aAAe,EACnCkD,EAAU6hB,EAAM7hB,QAChB8hB,EAAKD,EAAMviB,KAAKV,OAChBmjB,EAAKF,EAAMviB,KAAKX,MAChBqjB,GAAMD,EAAK,EACXE,GAAMH,EAAK,EAEf,MAAO,CACLI,MAAO,CACLtoB,EAAGooB,EAAKhiB,EAAQgL,KAAOlO,EACvBjD,EAAGooB,EAAKjiB,EAAQiL,IAAMnO,EACtBsI,EAAG2c,EAAK/hB,EAAQrB,MAAsB,EAAd7B,EACxBuI,EAAGyc,EAAK9hB,EAAQpB,OAAuB,EAAd9B,GAE3ByK,KAAM,CACJ3N,EAAGooB,EACHnoB,EAAGooB,EACH7c,EAAG2c,EACH1c,EAAGyc,IAKT,SAASK,EAAenI,EAAI1L,GAC1B,IAAIvE,EAAQuE,EAAQhN,MAAMmQ,eAAenD,EAAQ8T,cAAcC,OAE/D,IAAKtY,EACH,OAAO,KAGT,QAAsB8G,IAAlB9G,EAAMuY,cAA2CzR,IAAlB9G,EAAMwY,QACvC,MAAO,CAAC3oB,EAAGmQ,EAAMuY,QAASzoB,EAAGkQ,EAAMwY,SAGrC,IAAIC,EAAQzY,EAAM0Y,eAClB,OAAOzI,EAAG0H,WACR,CAAC9nB,EAAG4oB,EAAO3oB,EAAG,MACd,CAACD,EAAG,KAAMC,EAAG2oB,GAGjB,SAASE,EAAc1I,GACrB,OAAIA,aAAc,OACTmH,EAAYja,IAEjB8S,aAAc,OACTmH,EAAYnmB,MAEjBgf,aAAc,OACTmH,EAAYI,IAEdJ,EAAYnX,SAGrB,SAAS2Y,EAAgB5f,EAAKnJ,EAAGC,EAAGuL,EAAGC,EAAG5I,GACxC,IAAImmB,EAAUznB,KAAKilB,GAAK,EAExB,GAAI3jB,EAAQ,CACV,IAAIqb,EAAI3c,KAAK1C,IAAIgE,EAAQ4I,EAAI,EAAGD,EAAI,GAChC4F,EAAOpR,EAAIke,EACX7M,EAAMpR,EAAIie,EACV3M,EAAQvR,EAAIwL,EAAI0S,EAChB1M,EAASvR,EAAIwL,EAAIyS,EAErB/U,EAAIoE,OAAOvN,EAAGqR,GACVD,EAAOG,GAASF,EAAMG,GACxBrI,EAAImE,IAAI8D,EAAMC,EAAK6M,GAAI3c,KAAKilB,IAAKwC,GACjC7f,EAAImE,IAAIiE,EAAOF,EAAK6M,GAAI8K,EAAS,GACjC7f,EAAImE,IAAIiE,EAAOC,EAAQ0M,EAAG,EAAG8K,GAC7B7f,EAAImE,IAAI8D,EAAMI,EAAQ0M,EAAG8K,EAASznB,KAAKilB,KAC9BpV,EAAOG,GAChBpI,EAAIoE,OAAO6D,EAAMnR,GACjBkJ,EAAImE,IAAIiE,EAAOF,EAAK6M,GAAI8K,EAASA,GACjC7f,EAAImE,IAAI8D,EAAMC,EAAK6M,EAAG8K,EAASznB,KAAKilB,GAAKwC,IAChC3X,EAAMG,GACfrI,EAAImE,IAAI8D,EAAMC,EAAK6M,GAAI3c,KAAKilB,GAAI,GAChCrd,EAAImE,IAAI8D,EAAMI,EAAQ0M,EAAG,EAAG3c,KAAKilB,KAEjCrd,EAAImE,IAAI8D,EAAMC,EAAK6M,GAAI3c,KAAKilB,GAAIjlB,KAAKilB,IAEvCrd,EAAIwC,YACJxC,EAAIoE,OAAOvN,EAAGC,QAEdkJ,EAAI5F,KAAKvD,EAAGC,EAAGuL,EAAGC,GAItB,SAASwd,EAAU9f,EAAK5F,EAAM0kB,GAC5B,IAAIiB,EAAUjB,EAAM3c,gBAChBtB,EAAcie,EAAMje,YACpB9G,EAAc+kB,EAAM/kB,aAEnBgmB,GAAalf,GAAgB9G,KAIlCiG,EAAIoC,YAEJwd,EACE5f,EACA0c,EAAUtiB,EAAKvD,GAAKkD,EAAc,EAClC2iB,EAAUtiB,EAAKtD,GAAKiD,EAAc,EAClC2iB,EAAUtiB,EAAKiI,GAAKtI,EACpB2iB,EAAUtiB,EAAKkI,GAAKvI,EACpB+kB,EAAMvc,cAERvC,EAAIwC,YAEAud,IACF/f,EAAIkC,UAAY6d,EAChB/f,EAAIyC,QAGF5B,GAAe9G,IACjBiG,EAAIY,YAAcC,EAClBb,EAAIW,UAAY5G,EAChBiG,EAAIS,SAAW,QACfT,EAAIiC,WAIR,SAAS+d,EAAa5lB,EAAMgjB,EAAOxf,GACjC,IAAI0E,EAAI1E,EAAKK,WACToE,EAAIjI,EAAKiI,EACTxL,EAAIuD,EAAKvD,EACTC,EAAIsD,EAAKtD,EAAIwL,EAAI,EAQrB,MANc,WAAV8a,EACFvmB,GAAKwL,EAAI,EACU,QAAV+a,GAA6B,UAAVA,IAC5BvmB,GAAKwL,GAGA,CACLC,EAAGA,EACHD,EAAGA,EACHxL,EAAGA,EACHC,EAAGA,GAIP,SAASmpB,EAAajgB,EAAKwE,EAAM0b,GAC/B,IAAIC,EAASngB,EAAIiB,WACbmf,EAAUF,EAAIE,QACdvpB,EAAI6lB,EAAUwD,EAAIrpB,GAClBC,EAAI4lB,EAAUwD,EAAIppB,GAClBuL,EAAIqa,EAAUwD,EAAI7d,GAElB+d,GACFpgB,EAAI6E,WAAWL,EAAM3N,EAAGC,EAAGuL,GAGzB6d,EAAIG,SACFF,GAAUC,IAGZpgB,EAAIiB,WAAa,GAGnBjB,EAAI+E,SAASP,EAAM3N,EAAGC,EAAGuL,GAErB8d,GAAUC,IACZpgB,EAAIiB,WAAakf,IAKvB,SAASG,EAAStgB,EAAKuB,EAAOnH,EAAM0kB,GAClC,IAQI5jB,EARAkiB,EAAQ0B,EAAMliB,UACdwG,EAAQ0b,EAAM1b,MACdid,IAAWjd,EACXxF,EAAOkhB,EAAMlhB,KACbue,EAAO5a,EAAM5I,OACb4nB,EAAczB,EAAMnb,gBACpBtC,EAAcyd,EAAMxd,gBACpB8e,EAAUG,GAAelf,EAG7B,GAAK8a,IAAUkE,GAAWD,GAsB1B,IAjBAhmB,EAAO4lB,EAAa5lB,EAAMgjB,EAAOxf,GAEjCoC,EAAIpC,KAAOA,EAAK+B,OAChBK,EAAIpD,UAAYwgB,EAChBpd,EAAIsD,aAAe,SACnBtD,EAAIiB,WAAa6d,EAAM0B,eACvBxgB,EAAIe,YAAc+d,EAAM2B,gBAEpBJ,IACFrgB,EAAIkC,UAAYkB,GAEdgd,IACFpgB,EAAIS,SAAW,QACfT,EAAIW,UAAYU,EAChBrB,EAAIY,YAAc2f,GAGfrlB,EAAI,EAAGihB,EAAO5a,EAAM5I,OAAQuC,EAAIihB,IAAQjhB,EAC3C+kB,EAAajgB,EAAKuB,EAAMrG,GAAI,CAC1BklB,QAASA,EACTC,OAAQA,EACRhe,EAAGjI,EAAKiI,EACRxL,EAAGuD,EAAKvD,EACRC,EAAGsD,EAAKtD,EAAIsD,EAAKkI,EAAIpH,IAK3B,IAAIwlB,EAAQ,SAASxC,EAAQle,EAAKiX,EAAIxQ,GACpC,IAAIka,EAAK/S,KAET+S,EAAGC,QAAU1C,EACbyC,EAAG7oB,OAAS2O,EACZka,EAAGE,OAAS,KACZF,EAAGG,OAAS,KACZH,EAAGI,KAAO/gB,EACV2gB,EAAGK,IAAM/J,GAGX,eAAMyJ,EAAMO,UAAW,CAIrBC,UAAW,SAAS3b,EAAShE,EAAO2c,EAAQ3S,GAC1C,IAAIoV,EAAK/S,KACLnH,EAAQka,EAAG7oB,OACX8F,EAAO,eAAO,eAAQ,CAACsgB,EAAOtgB,KAAM,IAAK2N,EAAS9E,IAClDrD,EAAQ,eAAQ,CAAC8a,EAAO9a,MAAO,QAAWA,OAAQmI,EAAS9E,GAE/D,MAAO,CACL2W,MAAO,eAAQ,CAACc,EAAOd,MAAO,UAAW7R,EAAS9E,GAClD0X,OAAQ,eAAQ,CAACD,EAAOC,OAAQ,UAAW5S,EAAS9E,GACpDyC,KAAMqC,EAAQhN,MAAMuJ,UACpB3F,gBAAiB,eAAQ,CAAC+b,EAAO/b,gBAAiB,MAAOoJ,EAAS9E,GAClE5F,YAAa,eAAQ,CAACqd,EAAOrd,YAAa,MAAO0K,EAAS9E,GAC1DlE,aAAc,eAAQ,CAAC2b,EAAO3b,aAAc,GAAIgJ,EAAS9E,GACzD1M,YAAa,eAAQ,CAACmkB,EAAOnkB,YAAa,GAAIwR,EAAS9E,GACvDjR,MAAO,eAAQ,CAAC0oB,EAAO1oB,OAAO,GAAQ+V,EAAS9E,GAC/C6T,KAAM,eAAQ,CAAC4D,EAAO5D,MAAM,GAAQ/O,EAAS9E,GAC7CrD,MAAOA,EACPmC,QAASA,EACT3H,KAAMA,EACN2D,MAAOA,EACPiU,OAAQ,eAAQ,CAAC0I,EAAO1I,OAAQ,GAAIjK,EAAS9E,GAC7C1D,QAAS,eAAQ,CAACmb,EAAOnb,QAAS,GAAIwI,EAAS9E,GAC/CoW,OAAQuC,EAAeuB,EAAGK,IAAKzV,GAC/BtO,QAAS,eAAU,eAAQ,CAACihB,EAAOjhB,QAAS,GAAIsO,EAAS9E,IACzD0a,WAAYxB,EAAcgB,EAAGK,KAC7B3mB,SAAU,eAAQ,CAAC6jB,EAAO7jB,SAAU,GAAIkR,EAAS9E,IAAUrO,KAAKilB,GAAK,KACrE9gB,KAAMmf,EAAM1H,SAAS2M,EAAGI,KAAMxf,EAAO3D,GACrChB,UAAW,eAAQ,CAACshB,EAAOthB,UAAW,SAAU2O,EAAS9E,GACzD+Z,eAAgB,eAAQ,CAACtC,EAAOsC,eAAgB,GAAIjV,EAAS9E,GAC7Dga,gBAAiB,eAAQ,CAACvC,EAAOuC,gBAAiBrd,GAAQmI,EAAS9E,GACnE9C,gBAAiB,eAAQ,CAACua,EAAOva,gBAAiBP,GAAQmI,EAAS9E,GACnEnF,gBAAiB,eAAQ,CAAC4c,EAAO5c,gBAAiB,GAAIiK,EAAS9E,KAInEmR,OAAQ,SAASrM,GACf,IAKI9V,EAAO0G,EAAOoF,EALdof,EAAK/S,KACLkR,EAAQ,KACRsC,EAAQ,KACR3a,EAAQka,EAAG7oB,OACXomB,EAASyC,EAAGC,QAKZrb,EAAU,eAAQ,CAAC2Y,EAAO3Y,SAAS,GAAOgG,EAAS9E,GAEnDlB,IACF9P,EAAQ8V,EAAQ8V,QAAQnS,KAAKzI,GAC7BtK,EAAQ,eAAe,eAAS+hB,EAAOoD,UAAW,CAAC7rB,EAAO8V,IAAW9V,GACrE8L,EAAQ,eAAcpF,GAAS,GAAKuf,EAAMC,YAAYxf,GAElDoF,EAAM5I,SACRmmB,EAAQ6B,EAAGO,UAAU3b,EAAShE,EAAO2c,EAAQ3S,GAC7C6V,EAAQvC,EAAcC,KAI1B6B,EAAGE,OAAS/B,EACZ6B,EAAGG,OAASM,GAGdG,SAAU,WACR,OAAO3T,KAAKkT,OAASlT,KAAKkT,OAAO3B,MAAQ,IAG3C9kB,SAAU,WACR,OAAOuT,KAAKiT,OAASjT,KAAKiT,OAAOxmB,SAAW,GAG9CsW,QAAS,WACP,OAAO/C,KAAKiT,QAAUjT,KAAKiT,OAAO9d,SAGpC+b,MAAO,WACL,OAAOlR,KAAKiT,QAGdxG,KAAM,SAAS9b,EAAOvH,GACpB,IAIIkS,EAJAyX,EAAK/S,KACL5N,EAAMzB,EAAMyB,IACZ8e,EAAQ6B,EAAGE,OACXO,EAAQT,EAAGG,OAGVlT,KAAK+C,YAIV3Q,EAAIgC,OAEA8c,EAAMxE,OACRpR,EAAO4V,EAAM5V,KACblJ,EAAIoC,YACJpC,EAAI5F,KACF8O,EAAKjB,KACLiB,EAAKhB,IACLgB,EAAKd,MAAQc,EAAKjB,KAClBiB,EAAKb,OAASa,EAAKhB,KACrBlI,EAAIsa,QAGNta,EAAI6C,YAAc6Y,EAAMU,MAAM,EAAG0C,EAAM/b,QAAS,GAChD/C,EAAID,UAAU2c,EAAU1lB,EAAOH,GAAI6lB,EAAU1lB,EAAOF,IACpDkJ,EAAIC,OAAO6e,EAAMzkB,UAEjBylB,EAAU9f,EAAKohB,EAAMjC,MAAOL,GAC5BwB,EAAStgB,EAAK8e,EAAMvd,MAAO6f,EAAM5c,KAAMsa,GAEvC9e,EAAI2C,cAIR,IAAI6e,EAAcrqB,OAAOsqB,mBAAqB,iBAC1CC,EAAcvqB,OAAOwqB,kBAAoB,iBAE7C,SAAS3pB,EAAQC,EAAOjB,EAAQkB,GAC9B,IAAIC,EAAMC,KAAKD,IAAID,GACfG,EAAMD,KAAKC,IAAIH,GACfI,EAAKtB,EAAOH,EACZ0B,EAAKvB,EAAOF,EAEhB,MAAO,CACLD,EAAGyB,EAAKH,GAAOF,EAAMpB,EAAIyB,GAAMD,GAAOJ,EAAMnB,EAAIyB,GAChDzB,EAAGyB,EAAKF,GAAOJ,EAAMpB,EAAIyB,GAAMH,GAAOF,EAAMnB,EAAIyB,IAIpD,SAASqpB,EAAUvK,EAAQ/gB,GACzB,IAGI4E,EAAGoZ,EAAI4I,EAAIC,EAAI0E,EAHfnsB,EAAMgsB,EACN/rB,EAAM6rB,EACN3E,EAASvmB,EAAKumB,OAGlB,IAAK3hB,EAAI,EAAGA,EAAImc,EAAO1e,SAAUuC,EAC/BoZ,EAAK+C,EAAOnc,GACZgiB,EAAK5I,EAAGzd,EAAIgmB,EAAOhmB,EACnBsmB,EAAK7I,EAAGxd,EAAI+lB,EAAO/lB,EACnB+qB,EAAKvrB,EAAK4mB,GAAKA,EAAK5mB,EAAK6mB,GAAKA,EAC9BznB,EAAM0C,KAAK1C,IAAIA,EAAKmsB,GACpBlsB,EAAMyC,KAAKzC,IAAIA,EAAKksB,GAGtB,MAAO,CACLnsB,IAAKA,EACLC,IAAKA,GAIT,SAASmsB,EAAOC,EAAI/Q,GAClB,IAAIkM,EAAKlM,EAAGna,EAAIkrB,EAAGlrB,EACfsmB,EAAKnM,EAAGla,EAAIirB,EAAGjrB,EACfkmB,EAAK5kB,KAAKgY,KAAK8M,EAAKA,EAAKC,EAAKA,GAElC,MAAO,CACLD,IAAKlM,EAAGna,EAAIkrB,EAAGlrB,GAAKmmB,EACpBG,IAAKnM,EAAGla,EAAIirB,EAAGjrB,GAAKkmB,EACpBH,OAAQkF,EACR/E,GAAIA,GAIR,IAAIgF,EAAS,WACXpU,KAAKqU,UAAY,EACjBrU,KAAKsU,MAAQ,CACXrrB,EAAG,EACHC,EAAG,EACHuL,EAAG,EACHC,EAAG,IAsFP,SAAS6f,EAAYlL,EAAI6H,EAAOyC,GAC9B,IAAItpB,EAAQ6mB,EAAMqC,WAAWlK,EAAI6H,GAC7B5B,EAAKjlB,EAAMilB,GACXC,EAAKllB,EAAMklB,GAEf,IAAKD,IAAOC,EAEV,MAAO,CAACtmB,EAAGoB,EAAMpB,EAAGC,EAAGmB,EAAMnB,GAG/B,IAAIuL,EAAIkf,EAASlf,EACbC,EAAIif,EAASjf,EAGbjI,EAAWykB,EAAMzkB,SACjBsZ,EAAKvb,KAAKgZ,IAAI/O,EAAI,EAAIjK,KAAKD,IAAIkC,IAAajC,KAAKgZ,IAAI9O,EAAI,EAAIlK,KAAKC,IAAIgC,IACtEuZ,EAAKxb,KAAKgZ,IAAI/O,EAAI,EAAIjK,KAAKC,IAAIgC,IAAajC,KAAKgZ,IAAI9O,EAAI,EAAIlK,KAAKD,IAAIkC,IAKtE+nB,EAAK,EAAIhqB,KAAKzC,IAAIyC,KAAKgZ,IAAI8L,GAAK9kB,KAAKgZ,IAAI+L,IAQ7C,OAPAxJ,GAAMuJ,EAAKkF,EACXxO,GAAMuJ,EAAKiF,EAGXzO,GAAMmL,EAAMtJ,OAAS0H,EACrBtJ,GAAMkL,EAAMtJ,OAAS2H,EAEd,CACLtmB,EAAGoB,EAAMpB,EAAI8c,EACb7c,EAAGmB,EAAMnB,EAAI8c,GAIjB,SAASyO,EAAQnf,EAAQof,GACvB,IAAIpnB,EAAGshB,EAAG+F,EAAIC,EAMd,IAAKtnB,EAAIgI,EAAOvK,OAAS,EAAGuC,GAAK,IAAKA,EAGpC,IAFAqnB,EAAKrf,EAAOhI,GAAGunB,QAEVjG,EAAIthB,EAAI,EAAGshB,GAAK,GAAK+F,EAAG3R,WAAY4L,EACvCgG,EAAKtf,EAAOsZ,GAAGiG,QAEXD,EAAG5R,UAAY2R,EAAGG,KAAKnQ,WAAWiQ,EAAGE,OACvCJ,EAASC,EAAIC,GAKnB,OAAOtf,EAGT,SAASyf,EAAQzf,GACf,IAAIhI,EAAGihB,EAAMhgB,EAAOwO,EAAO4W,EAAUvqB,EAAQ4rB,EAG7C,IAAK1nB,EAAI,EAAGihB,EAAOjZ,EAAOvK,OAAQuC,EAAIihB,IAAQjhB,EAC5CiB,EAAQ+G,EAAOhI,GACfyP,EAAQxO,EAAMsmB,QAEV9X,EAAMiG,WAMRgS,EAAQ,IAAIC,MAAM1mB,EAAM6kB,IAAK,CAAClf,IAAK,CAACmV,EAAIZ,IAAMY,EAAGtc,SAAS,CAAC0b,IAAI,GAAMA,KAErEkL,EAAWplB,EAAMolB,WACjBvqB,EAASmrB,EAAYS,EAAOzmB,EAAM2iB,QAASyC,GAC3C5W,EAAM+X,KAAK9K,OAAO5gB,EAAQuqB,EAAUplB,EAAM9B,aAK9C,OAAOgoB,EAAQnf,GAAQ,SAASqf,EAAIC,GAClC,IAAIM,EAAKP,EAAGQ,SACRC,EAAKR,EAAGO,SAEPD,GAAME,GAAOA,EAChBR,EAAG5R,UAAW,EACLkS,IACTP,EAAG3R,UAAW,MAzKpB,eAAMoR,EAAOf,UAAW,CACtBjqB,OAAQ,WACN,IAAI+d,EAAInH,KAAKsU,MACb,MAAO,CACLrrB,EAAGke,EAAEle,EAAIke,EAAE1S,EAAI,EACfvL,EAAGie,EAAEje,EAAIie,EAAEzS,EAAI,IAInBsV,OAAQ,SAAS5gB,EAAQoD,EAAMC,GAC7BuT,KAAKqU,UAAY5nB,EACjBuT,KAAKsU,MAAQ,CACXrrB,EAAGuD,EAAKvD,EAAIG,EAAOH,EACnBC,EAAGsD,EAAKtD,EAAIE,EAAOF,EACnBuL,EAAGjI,EAAKiI,EACRC,EAAGlI,EAAKkI,IAIZ2gB,SAAU,SAAShrB,GACjB,IAAI0oB,EAAK/S,KACL5H,EAAS,EACT5L,EAAOumB,EAAGuB,MAId,OAFAjqB,EAAQD,EAAQC,EAAO0oB,EAAG3pB,UAAW2pB,EAAGsB,aAE/BhqB,EAAMpB,EAAIuD,EAAKvD,EAAImP,GACvB/N,EAAMnB,EAAIsD,EAAKtD,EAAIkP,GACnB/N,EAAMpB,EAAIuD,EAAKvD,EAAIuD,EAAKiI,EAAa,EAAT2D,GAC5B/N,EAAMnB,EAAIsD,EAAKtD,EAAIsD,EAAKkI,EAAa,EAAT0D,IAKnCuM,WAAY,SAAS2Q,GACnB,IAMIhoB,EAAGioB,EAAKC,EANRrF,EAAKnQ,KAAKyV,UACVrF,EAAKkF,EAAMG,UACX7b,EAAO,CACTsa,EAAO/D,EAAG,GAAIA,EAAG,IACjB+D,EAAO/D,EAAG,GAAIA,EAAG,KAanB,IATInQ,KAAKqU,YAAciB,EAAMjB,WAG3Bza,EAAK9P,KACHoqB,EAAO9D,EAAG,GAAIA,EAAG,IACjB8D,EAAO9D,EAAG,GAAIA,EAAG,KAIhB9iB,EAAI,EAAGA,EAAIsM,EAAK7O,SAAUuC,EAI7B,GAHAioB,EAAMvB,EAAU7D,EAAIvW,EAAKtM,IACzBkoB,EAAMxB,EAAU5D,EAAIxW,EAAKtM,IAErBioB,EAAIxtB,IAAMytB,EAAI1tB,KAAO0tB,EAAIztB,IAAMwtB,EAAIztB,IACrC,OAAO,EAIX,OAAO,GAMT2tB,QAAS,WACP,IAAI1C,EAAK/S,KACLxT,EAAOumB,EAAGuB,MACVhqB,EAAQyoB,EAAGsB,UACXjrB,EAAS2pB,EAAG3pB,SAEhB,MAAO,CACLgB,EAAQ,CAACnB,EAAGuD,EAAKvD,EAAGC,EAAGsD,EAAKtD,GAAIE,EAAQkB,GACxCF,EAAQ,CAACnB,EAAGuD,EAAKvD,EAAIuD,EAAKiI,EAAGvL,EAAGsD,EAAKtD,GAAIE,EAAQkB,GACjDF,EAAQ,CAACnB,EAAGuD,EAAKvD,EAAIuD,EAAKiI,EAAGvL,EAAGsD,EAAKtD,EAAIsD,EAAKkI,GAAItL,EAAQkB,GAC1DF,EAAQ,CAACnB,EAAGuD,EAAKvD,EAAGC,EAAGsD,EAAKtD,EAAIsD,EAAKkI,GAAItL,EAAQkB,OAiGvD,IAAIorB,EAAS,CACXC,QAAS,SAASC,GAChB,IACItoB,EAAGshB,EAAGL,EAAMsH,EAAMtnB,EADlB+G,EAAS,GAGb,IAAKhI,EAAI,EAAGihB,EAAOqH,EAAS7qB,OAAQuC,EAAIihB,IAAQjhB,EAC9C,IAAKshB,EAAI,EAAGiH,EAAOD,EAAStoB,GAAGvC,OAAQ6jB,EAAIiH,IAAQjH,EACjDrgB,EAAQqnB,EAAStoB,GAAGshB,GACpBtZ,EAAOxL,KAAKyE,GACZA,EAAMsmB,QAAU,CACdC,KAAM,IAAIV,EACVe,UAAU,EACVnS,UAAU,EACV8S,KAAMxoB,EACNyoB,KAAMxnB,EAAMrE,QAmBlB,OAXAoL,EAAOvL,MAAK,SAASC,EAAGC,GACtB,IAAI+rB,EAAKhsB,EAAE6qB,QACPoB,EAAKhsB,EAAE4qB,QAEX,OAAOmB,EAAGD,OAASE,EAAGF,KAClBE,EAAGH,KAAOE,EAAGF,KACbG,EAAGF,KAAOC,EAAGD,QAGnB/V,KAAKgK,OAAO1U,GAELA,GAGT0U,OAAQ,SAAS1U,GACf,IACIhI,EAAGihB,EAAMhgB,EAAO2iB,EAAOnU,EADvBmZ,GAAQ,EAGZ,IAAK5oB,EAAI,EAAGihB,EAAOjZ,EAAOvK,OAAQuC,EAAIihB,IAAQjhB,EAC5CiB,EAAQ+G,EAAOhI,GACf4jB,EAAQ3iB,EAAM2iB,QACdnU,EAAQxO,EAAMsmB,QACd9X,EAAMoY,SAAWjE,GAA2B,SAAlBA,EAAMvZ,QAChCoF,EAAMiG,SAAWzU,EAAMwU,UACvBmT,GAASnZ,EAAMoY,SAGbe,GACFnB,EAAQzf,IAIZ6gB,OAAQ,SAAS7gB,EAAQjL,GACvB,IAAIiD,EAAGyP,EAKP,IAAKzP,EAAIgI,EAAOvK,OAAS,EAAGuC,GAAK,IAAKA,EAGpC,GAFAyP,EAAQzH,EAAOhI,GAAGunB,QAEd9X,GAASA,EAAMiG,UAAYjG,EAAM+X,KAAKO,SAAShrB,GACjD,OAAOiL,EAAOhI,GAIlB,OAAO,MAGTmf,KAAM,SAAS9b,EAAO2E,GACpB,IAAIhI,EAAGihB,EAAMhgB,EAAOwO,EAAO4W,EAAUvqB,EAErC,IAAKkE,EAAI,EAAGihB,EAAOjZ,EAAOvK,OAAQuC,EAAIihB,IAAQjhB,EAC5CiB,EAAQ+G,EAAOhI,GACfyP,EAAQxO,EAAMsmB,QAEV9X,EAAMiG,WACR2Q,EAAWplB,EAAMolB,WACjBvqB,EAASmrB,EAAYhmB,EAAM6kB,IAAK7kB,EAAM2iB,QAASyC,GAC/C5W,EAAM+X,KAAK9K,OAAO5gB,EAAQuqB,EAAUplB,EAAM9B,YAC1C8B,EAAMke,KAAK9b,EAAOvH,MAMtBsqB,EAAY,SAAS7rB,GACvB,GAAI,eAAcA,GAChB,OAAO,KAGT,IACI+D,EAAMwqB,EAAMC,EADZ9nB,EAAQ1G,EAEZ,GAAI,eAASA,GACX,GAAK,eAAcA,EAAM0G,OAElB,GAAK,eAAc1G,EAAMsf,GAK9B,IAFA5Y,EAAQ,GACR3C,EAAOD,OAAOC,KAAK/D,GACdwuB,EAAI,EAAGD,EAAOxqB,EAAKb,OAAQsrB,EAAID,IAAQC,EAC1C9nB,IAAgB,IAAN8nB,EAAU,KAAO,IAAMzqB,EAAKyqB,GAAK,KAAOxuB,EAAM+D,EAAKyqB,SAL/D9nB,EAAQ1G,EAAMsf,OAFd5Y,EAAQ1G,EAAM0G,MAYlB,MAAO,GAAKA,GAQV0R,EAAW,CACbuP,MAAO,SACPe,OAAQ,SACRhc,gBAAiB,KACjBtB,YAAa,KACb0B,aAAc,EACdxI,YAAa,EACbvE,OAAO,EACP8kB,MAAM,EACNlX,WAAO0K,EACPvI,SAAS,EACT3H,KAAM,CACJoQ,YAAQF,EACR7P,WAAY,IACZ1B,UAAMuR,EACN9K,WAAO8K,EACPG,OAAQ,MAEVqT,UAAWA,EACXpe,YAAQ4K,EACRjD,UAAW,GACX2K,OAAQ,EACRzS,QAAS,EACT9F,QAAS,CACPiL,IAAK,EACLE,MAAO,EACPC,OAAQ,EACRJ,KAAM,GAER5N,SAAU,EACVuC,UAAW,QACX+G,qBAAiBmK,EACjBxM,gBAAiB,EACjBkf,eAAgB,EAChBC,qBAAiB3S,GAOfoW,EAAc,cACdC,EAAc,WAElB,SAASC,EAAU/C,EAASjrB,GAC1B,IAGI8M,EAAQ1J,EAHR+f,EAAW8H,EAAQgD,WACnBxZ,EAAY,GACZyZ,EAAU,GAGd,OAAiB,IAAb/K,EACK,OAEQ,IAAbA,IACFA,EAAW,IAGbnjB,EAAU,eAAM,GAAI,CAACA,EAASmjB,IAC9BrW,EAAS9M,EAAQ8M,QAAU,GAC3B1J,EAAOD,OAAOC,KAAK0J,UACZ9M,EAAQ8M,OAEX1J,EAAKb,OACPa,EAAKwF,SAAQ,SAAS1F,GAChB4J,EAAO5J,IACTgrB,EAAQ5sB,KAAK,eAAM,GAAI,CACrBtB,EACA8M,EAAO5J,GACP,CAACirB,KAAMjrB,SAMbgrB,EAAQ5sB,KAAKtB,GAIfyU,EAAYyZ,EAAQjtB,QAAO,SAASmtB,EAAQtG,GAO1C,OANA,eAAKA,EAAOrT,WAAa,IAAI,SAAS4Z,EAAIxuB,GACxCuuB,EAAOvuB,GAASuuB,EAAOvuB,IAAU,GACjCuuB,EAAOvuB,GAAOioB,EAAOqG,MAAQJ,GAAeM,YAGvCvG,EAAOrT,UACP2Z,IACN,IAEI,CACLthB,OAAQohB,EACRzZ,UAAWA,IAIf,SAASe,EAAcrN,EAAOsM,EAAW1O,EAAOlG,GAC9C,GAAK4U,EAAL,CAIA,IAEI6Z,EAFAnZ,EAAUpP,EAAM2P,SAChB6Y,EAASxoB,EAAMyoB,QAGd/Z,EAAU8Z,EAAOjB,QAItBgB,EAAa7Z,EAAU8Z,EAAOjB,MAAMiB,EAAOJ,MACtCG,IAI0C,IAA3C,eAASA,EAAY,CAACnZ,EAAStV,MAKjCsI,EAAM2lB,GAAaW,QAAS,EAC5B1oB,EAAMyb,OAAOrM,MAIjB,SAASE,EAAmBlN,EAAOsM,EAAWQ,EAAUlP,EAAOlG,GAC7D,IAAI6uB,EAAOC,GAEN1Z,GAAalP,KAIbkP,EAEOlP,EAEDkP,IAAalP,IACtB4oB,EAAQD,GAAQ,GAFhBC,GAAQ,EAFRD,GAAQ,EAONC,GACFnZ,EAAcrN,EAAOsM,EAAUka,MAAO1Z,EAAUpV,GAE9C6uB,GACFlZ,EAAcrN,EAAOsM,EAAUia,MAAO3oB,EAAOlG,IAIjD,SAASkV,EAAiB5M,EAAOtI,GAC/B,IAEIoV,EAAUlP,EAFV6oB,EAAUzmB,EAAM2lB,GAChBrZ,EAAYma,EAAQC,WAGxB,GAAKpa,EAAUia,OAAUja,EAAUka,MAAnC,CAIA,GAAmB,cAAf9uB,EAAMiJ,KACR/C,EAAQmnB,EAAOS,OAAOiB,EAAQE,QAASjvB,QAClC,GAAmB,aAAfA,EAAMiJ,KACf,OAGFmM,EAAW2Z,EAAQG,SACnBH,EAAQG,SAAWhpB,EACnBsP,EAAmBlN,EAAOsM,EAAWQ,EAAUlP,EAAOlG,IAGxD,SAASmV,EAAkB7M,EAAOtI,GAChC,IAAI+uB,EAAUzmB,EAAM2lB,GAChBkB,EAAWJ,EAAQC,WAAWha,MAC9B9O,EAAQipB,GAAY9B,EAAOS,OAAOiB,EAAQE,QAASjvB,GACnDkG,GACFyP,EAAcrN,EAAO6mB,EAAUjpB,EAAOlG,GAI1C,IAAIovB,EAAS,CACX3d,GAAI,aAEJmG,SAAUA,EAEVyX,WAAY,SAAS/mB,GACnBA,EAAM2lB,GAAe,CACnBqB,SAAU,KAIdC,aAAc,SAASjnB,GACrB,IAAIymB,EAAUzmB,EAAM2lB,GACpBc,EAAQS,WAAY,EACpBT,EAAQC,WAAa,GACrBD,EAAQU,UAAY,GACpBV,EAAQE,QAAU,IAGpBS,mBAAoB,SAASpnB,EAAO4b,EAAM/jB,GACxC,IAQI8E,EAAGshB,EAAGL,EAAMsH,EAAMvD,EAAK5mB,EAAK2d,EAAI9a,EARhCkjB,EAAelF,EAAK1T,MACpBue,EAAUzmB,EAAM2lB,GAChBhhB,EAAS8hB,EAAQU,UAAUrG,GAAgB,GAC3C1O,EAAUpS,EAAMqnB,iBAAiBvG,GACjCgC,EAAU9iB,EAAM2Q,KAAKsU,SAASnE,GAC9BnB,EAASkG,EAAU/C,EAASjrB,GAC5BmT,EAAW4Q,EAAK1L,KAAKS,MAAQ,GAC7BlP,EAAMzB,EAAMyB,IAKhB,IAFAA,EAAIgC,OAEC9G,EAAI,EAAGihB,EAAO5S,EAAS5Q,OAAQuC,EAAIihB,IAAQjhB,EAI9C,GAHA+b,EAAK1N,EAASrO,GACd+b,EAAGiN,GAAe,GAEdvT,GAAWsG,GAAM1Y,EAAMgR,kBAAkBrU,KAAO+b,EAAG4B,KACrD,IAAK2D,EAAI,EAAGiH,EAAOvF,EAAOhb,OAAOvK,OAAQ6jB,EAAIiH,IAAQjH,EACnD0D,EAAMhC,EAAOhb,OAAOsZ,GACpBljB,EAAM4mB,EAAIqE,KAEVpoB,EAAQ,IAAIukB,EAAMR,EAAKlgB,EAAKiX,EAAI/b,GAChCiB,EAAMyoB,QAAU,CACdlB,KAAMrE,EACNkF,KAAMjrB,GAAO6qB,GAEfhoB,EAAM2P,SAAW,CACf+Z,QAAQ,EACRtnB,MAAOA,EACPunB,UAAW5qB,EACXmmB,QAASA,EACThC,aAAcA,GAGhBljB,EAAMyb,OAAOzb,EAAM2P,UACnBmL,EAAGiN,GAAaxsB,KAAKyE,GACrB+G,EAAOxL,KAAKyE,GAKlB6D,EAAI2C,UAIJ,eAAMqiB,EAAQC,WAAY/G,EAAOrT,UAAW,CAC1Ckb,OAAQ,SAAS9vB,EAAOuuB,EAAQwB,GAC9BxB,EAAOvuB,GAASuuB,EAAOvuB,IAAU,GACjCuuB,EAAOvuB,GAAOkkB,EAAK1T,OAASuf,EAAO/vB,GACnC+uB,EAAQS,WAAY,MAK1BQ,YAAa,SAAS1nB,GACpBA,EAAM2lB,GAAagB,QAAU5B,EAAOC,QAAQhlB,EAAM2lB,GAAawB,YAMjEQ,kBAAmB,SAAS3nB,GAC1B+kB,EAAOjJ,KAAK9b,EAAOA,EAAM2lB,GAAagB,UAGxCiB,YAAa,SAAS5nB,EAAO4b,GAI3B,GAAI5b,EAAM2lB,GAAauB,UAAW,CAChC,IAAIxvB,EAAQkkB,EAAKlkB,MACjB,OAAQA,EAAMiJ,MACd,IAAK,YACL,IAAK,WACHiM,EAAiB5M,EAAOtI,GACxB,MACF,IAAK,QACHmV,EAAkB7M,EAAOtI,GACzB,SAKNmwB,WAAY,SAAS7nB,GACnB,IAIIrD,EAAGihB,EAAMK,EAAGiH,EAAM7L,EAAQzb,EAAO+G,EAJjC8hB,EAAUzmB,EAAM2lB,GAChB7Y,EAAW2Z,EAAQO,SACnBc,EAAUrB,EAAQO,SAAWhnB,EAAM+nB,oBACnC7J,EAAUf,EAAMW,UAAUhR,EAAUgb,GAGxC,IAAKnrB,EAAI,EAAGihB,EAAOM,EAAQ9jB,OAAQuC,EAAIihB,IAAQjhB,EAE7C,GADA0c,EAAS6E,EAAQvhB,GACb0c,EAAO,GAET,IADA1U,EAAS0U,EAAO,GAAGjhB,QAAQutB,IAAgB,GACtC1H,EAAI,EAAGiH,EAAOvgB,EAAOvK,OAAQ6jB,EAAIiH,IAAQjH,EAC5CrgB,EAAQ+G,EAAOsZ,GACfrgB,EAAM2P,SAAS+Z,OAAwB,IAAdjO,EAAO,GAChCzb,EAAMyb,OAAOzb,EAAM2P,WAKrBkZ,EAAQH,QAAUpI,EAAQ9jB,UAC5B2qB,EAAO1L,OAAOoN,EAAQE,SACtB3mB,EAAMgoB,iBAGDvB,EAAQH","file":"js/chunk-vendors~739cf782.48324f86.js","sourcesContent":["module.exports = clamp\n\nfunction clamp(value, min, max) {\n  return min < max\n    ? (value < min ? min : value > max ? max : value)\n    : (value < max ? max : value > min ? min : value)\n}\n","/*!\n* chartjs-plugin-annotation v3.1.0\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2024 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, DoughnutController, defaults, Animations, Chart } from 'chart.js';\nimport { distanceBetweenPoints, toRadians, isObject, valueOrDefault, defined, isFunction, callback, isArray, toFont, addRoundedRectPath, toTRBLCorners, QUARTER_PI, PI, HALF_PI, TWO_THIRDS_PI, TAU, isNumber, RAD_PER_DEG, toPadding, isFinite, getAngleFromPoint, toDegrees, clipArea, unclipArea } from 'chart.js/helpers';\n\n/**\n * @typedef { import(\"chart.js\").ChartEvent } ChartEvent\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst interaction = {\n  modes: {\n    /**\n     * Point mode returns all elements that hit test based on the event position\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    point(visibleElements, event) {\n      return filterElements(visibleElements, event, {intersect: true});\n    },\n\n    /**\n     * Nearest mode returns the element closest to the event position\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found (only 1 element)\n     */\n    nearest(visibleElements, event, options) {\n      return getNearestItem(visibleElements, event, options);\n    },\n    /**\n     * x mode returns the elements that hit-test at the current x coordinate\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    x(visibleElements, event, options) {\n      return filterElements(visibleElements, event, {intersect: options.intersect, axis: 'x'});\n    },\n\n    /**\n     * y mode returns the elements that hit-test at the current y coordinate\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    y(visibleElements, event, options) {\n      return filterElements(visibleElements, event, {intersect: options.intersect, axis: 'y'});\n    }\n  }\n};\n\n/**\n * Returns all elements that hit test based on the event position\n * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n * @param {ChartEvent} event - the event we are find things at\n * @param {Object} options - interaction options to use\n * @return {AnnotationElement[]} - elements that are found\n */\nfunction getElements(visibleElements, event, options) {\n  const mode = interaction.modes[options.mode] || interaction.modes.nearest;\n  return mode(visibleElements, event, options);\n}\n\nfunction inRangeByAxis(element, event, axis) {\n  if (axis !== 'x' && axis !== 'y') {\n    return element.inRange(event.x, event.y, 'x', true) || element.inRange(event.x, event.y, 'y', true);\n  }\n  return element.inRange(event.x, event.y, axis, true);\n}\n\nfunction getPointByAxis(event, center, axis) {\n  if (axis === 'x') {\n    return {x: event.x, y: center.y};\n  } else if (axis === 'y') {\n    return {x: center.x, y: event.y};\n  }\n  return center;\n}\n\nfunction filterElements(visibleElements, event, options) {\n  return visibleElements.filter((element) => options.intersect ? element.inRange(event.x, event.y) : inRangeByAxis(element, event, options.axis));\n}\n\nfunction getNearestItem(visibleElements, event, options) {\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  return filterElements(visibleElements, event, options)\n    .reduce((nearestItems, element) => {\n      const center = element.getCenterPoint();\n      const evenPoint = getPointByAxis(event, center, options.axis);\n      const distance = distanceBetweenPoints(event, evenPoint);\n      if (distance < minDistance) {\n        nearestItems = [element];\n        minDistance = distance;\n      } else if (distance === minDistance) {\n        // Can have multiple items at the same distance in which case we sort by size\n        nearestItems.push(element);\n      }\n\n      return nearestItems;\n    }, [])\n    .sort((a, b) => a._index - b._index)\n    .slice(0, 1); // return only the top item;\n}\n\n/**\n * @typedef {import('chart.js').Point} Point\n */\n\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {Point} point - the point to rotate\n * @param {Point} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {Point} rotated point\n */\nfunction rotated(point, center, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const cx = center.x;\n  const cy = center.y;\n\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\nconst isOlderPart = (act, req) => req > act || (act.length > req.length && act.slice(0, req.length) === req);\n\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('chart.js').InteractionAxis } InteractionAxis\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst EPSILON = 0.001;\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\n/**\n * @param {{value: number, start: number, end: number}} limit\n * @param {number} hitSize\n * @returns {boolean}\n */\nconst inLimit = (limit, hitSize) => limit.value >= limit.start - hitSize && limit.value <= limit.end + hitSize;\n\n/**\n * @param {Object} obj\n * @param {number} from\n * @param {number} to\n * @returns {Object}\n */\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n  return obj;\n}\n\n/**\n * @param {Point} point\n * @param {Point} center\n * @param {number} radius\n * @param {number} hitSize\n * @returns {boolean}\n */\nfunction inPointRange(point, center, radius, hitSize) {\n  if (!point || !center || radius <= 0) {\n    return false;\n  }\n  return (Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2)) <= Math.pow(radius + hitSize, 2);\n}\n\n/**\n * @param {Point} point\n * @param {{x: number, y: number, x2: number, y2: number}} rect\n * @param {InteractionAxis} axis\n * @param {{borderWidth: number, hitTolerance: number}} hitsize\n * @returns {boolean}\n */\nfunction inBoxRange(point, {x, y, x2, y2}, axis, {borderWidth, hitTolerance}) {\n  const hitSize = (borderWidth + hitTolerance) / 2;\n  const inRangeX = point.x >= x - hitSize - EPSILON && point.x <= x2 + hitSize + EPSILON;\n  const inRangeY = point.y >= y - hitSize - EPSILON && point.y <= y2 + hitSize + EPSILON;\n  if (axis === 'x') {\n    return inRangeX;\n  } else if (axis === 'y') {\n    return inRangeY;\n  }\n  return inRangeX && inRangeY;\n}\n\n/**\n * @param {Point} point\n * @param {rect: {x: number, y: number, x2: number, y2: number}, center: {x: number, y: number}} element\n * @param {InteractionAxis} axis\n * @param {{rotation: number, borderWidth: number, hitTolerance: number}}\n * @returns {boolean}\n */\nfunction inLabelRange(point, {rect, center}, axis, {rotation, borderWidth, hitTolerance}) {\n  const rotPoint = rotated(point, center, toRadians(-rotation));\n  return inBoxRange(rotPoint, rect, axis, {borderWidth, hitTolerance});\n}\n\n/**\n * @param {AnnotationElement} element\n * @param {boolean} useFinalPosition\n * @returns {Point}\n */\nfunction getElementCenterPoint(element, useFinalPosition) {\n  const {centerX, centerY} = element.getProps(['centerX', 'centerY'], useFinalPosition);\n  return {x: centerX, y: centerY};\n}\n\n/**\n * @param {string} pkg\n * @param {string} min\n * @param {string} ver\n * @param {boolean} [strict=true]\n * @returns {boolean}\n */\nfunction requireVersion(pkg, min, ver, strict = true) {\n  const parts = ver.split('.');\n  let i = 0;\n  for (const req of min.split('.')) {\n    const act = parts[i++];\n    if (parseInt(req, 10) < parseInt(act, 10)) {\n      break;\n    }\n    if (isOlderPart(act, req)) {\n      if (strict) {\n        throw new Error(`${pkg} v${ver} is not supported. v${min} or newer is required.`);\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nconst isPercentString = (s) => typeof s === 'string' && s.endsWith('%');\nconst toPercent = (s) => parseFloat(s) / 100;\nconst toPositivePercent = (s) => clamp(toPercent(s), 0, 1);\n\nconst boxAppering = (x, y) => ({x, y, x2: x, y2: y, width: 0, height: 0});\nconst defaultInitAnimation = {\n  box: (properties) => boxAppering(properties.centerX, properties.centerY),\n  doughnutLabel: (properties) => boxAppering(properties.centerX, properties.centerY),\n  ellipse: (properties) => ({centerX: properties.centerX, centerY: properties.centerX, radius: 0, width: 0, height: 0}),\n  label: (properties) => boxAppering(properties.centerX, properties.centerY),\n  line: (properties) => boxAppering(properties.x, properties.y),\n  point: (properties) => ({centerX: properties.centerX, centerY: properties.centerY, radius: 0, width: 0, height: 0}),\n  polygon: (properties) => boxAppering(properties.centerX, properties.centerY)\n};\n\n/**\n * @typedef { import('chart.js').FontSpec } FontSpec\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('chart.js').Padding } Padding\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n * @typedef { import('../../types/options').AnnotationPointCoordinates } AnnotationPointCoordinates\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n * @typedef { import('../../types/label').LabelPositionObject } LabelPositionObject\n */\n\n/**\n * @param {number} size\n * @param {number|string} position\n * @returns {number}\n */\nfunction getRelativePosition(size, position) {\n  if (position === 'start') {\n    return 0;\n  }\n  if (position === 'end') {\n    return size;\n  }\n  if (isPercentString(position)) {\n    return toPositivePercent(position) * size;\n  }\n  return size / 2;\n}\n\n/**\n * @param {number} size\n * @param {number|string} value\n * @param {boolean} [positivePercent=true]\n * @returns {number}\n */\nfunction getSize(size, value, positivePercent = true) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (isPercentString(value)) {\n    return (positivePercent ? toPositivePercent(value) : toPercent(value)) * size;\n  }\n  return size;\n}\n\n/**\n * @param {{x: number, width: number}} size\n * @param {CoreLabelOptions} options\n * @returns {number}\n */\nfunction calculateTextAlignment(size, options) {\n  const {x, width} = size;\n  const textAlign = options.textAlign;\n  if (textAlign === 'center') {\n    return x + width / 2;\n  } else if (textAlign === 'end' || textAlign === 'right') {\n    return x + width;\n  }\n  return x;\n}\n\n/**\n * @param {Point} point\n * @param {{height: number, width: number}} labelSize\n * @param {{borderWidth: number, position: {LabelPositionObject|string}, xAdjust: number, yAdjust: number}} options\n * @param {Padding|undefined} padding\n * @returns {{x: number, y: number, x2: number, y2: number, height: number, width: number, centerX: number, centerY: number}}\n */\nfunction measureLabelRectangle(point, labelSize, {borderWidth, position, xAdjust, yAdjust}, padding) {\n  const hasPadding = isObject(padding);\n  const width = labelSize.width + (hasPadding ? padding.width : 0) + borderWidth;\n  const height = labelSize.height + (hasPadding ? padding.height : 0) + borderWidth;\n  const positionObj = toPosition(position);\n  const x = calculateLabelPosition$1(point.x, width, xAdjust, positionObj.x);\n  const y = calculateLabelPosition$1(point.y, height, yAdjust, positionObj.y);\n\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2\n  };\n}\n\n/**\n * @param {LabelPositionObject|string} value\n * @param {string|number} defaultValue\n * @returns {LabelPositionObject}\n */\nfunction toPosition(value, defaultValue = 'center') {\n  if (isObject(value)) {\n    return {\n      x: valueOrDefault(value.x, defaultValue),\n      y: valueOrDefault(value.y, defaultValue),\n    };\n  }\n  value = valueOrDefault(value, defaultValue);\n  return {\n    x: value,\n    y: value\n  };\n}\n\n/**\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n * @returns {boolean}\n */\nconst shouldFit = (options, fitRatio) => options && options.autoFit && fitRatio < 1;\n\n/**\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n * @returns {FontSpec[]}\n */\nfunction toFonts(options, fitRatio) {\n  const optFont = options.font;\n  const fonts = isArray(optFont) ? optFont : [optFont];\n  if (shouldFit(options, fitRatio)) {\n    return fonts.map(function(f) {\n      const font = toFont(f);\n      font.size = Math.floor(f.size * fitRatio);\n      font.lineHeight = f.lineHeight;\n      return toFont(font);\n    });\n  }\n  return fonts.map(f => toFont(f));\n}\n\n/**\n * @param {AnnotationPointCoordinates} options\n * @returns {boolean}\n */\nfunction isBoundToPoint(options) {\n  return options && (defined(options.xValue) || defined(options.yValue));\n}\n\nfunction calculateLabelPosition$1(start, size, adjust = 0, position) {\n  return start - getRelativePosition(size, position) + adjust;\n}\n\n/**\n * @param {Chart} chart\n * @param {AnnotationBoxModel} properties\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationElement}\n */\nfunction initAnimationProperties(chart, properties, options) {\n  const initAnim = options.init;\n  if (!initAnim) {\n    return;\n  } else if (initAnim === true) {\n    return applyDefault(properties, options);\n  }\n  return execCallback(chart, properties, options);\n}\n\n/**\n * @param {Object} options\n * @param {Array} hooks\n * @param {Object} hooksContainer\n * @returns {boolean}\n */\nfunction loadHooks(options, hooks, hooksContainer) {\n  let activated = false;\n  hooks.forEach(hook => {\n    if (isFunction(options[hook])) {\n      activated = true;\n      hooksContainer[hook] = options[hook];\n    } else if (defined(hooksContainer[hook])) {\n      delete hooksContainer[hook];\n    }\n  });\n  return activated;\n}\n\nfunction applyDefault(properties, options) {\n  const type = options.type || 'line';\n  return defaultInitAnimation[type](properties);\n}\n\nfunction execCallback(chart, properties, options) {\n  const result = callback(options.init, [{chart, properties, options}]);\n  if (result === true) {\n    return applyDefault(properties, options);\n  } else if (isObject(result)) {\n    return result;\n  }\n}\n\nconst widthCache = new Map();\nconst notRadius = (radius) => isNaN(radius) || radius <= 0;\nconst fontsKey = (fonts) => fonts.reduce(function(prev, item) {\n  prev += item.string;\n  return prev;\n}, '');\n\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n */\n\n/**\n * Determine if content is an image or a canvas.\n * @param {*} content\n * @returns boolean|undefined\n * @todo move this function to chart.js helpers\n */\nfunction isImageOrCanvas(content) {\n  if (content && typeof content === 'object') {\n    const type = content.toString();\n    return (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]');\n  }\n}\n\n/**\n * Set the translation on the canvas if the rotation must be applied.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Point} point - the point of translation\n * @param {number} rotation - rotation (in degrees) to apply\n */\nfunction translate(ctx, {x, y}, rotation) {\n  if (rotation) {\n    ctx.translate(x, y);\n    ctx.rotate(toRadians(rotation));\n    ctx.translate(-x, -y);\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n * @returns {boolean|undefined}\n */\nfunction setBorderStyle(ctx, options) {\n  if (options && options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle || 'butt';\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle || 'miter';\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n */\nfunction setShadowStyle(ctx, options) {\n  ctx.shadowColor = options.backgroundShadowColor;\n  ctx.shadowBlur = options.shadowBlur;\n  ctx.shadowOffsetX = options.shadowOffsetX;\n  ctx.shadowOffsetY = options.shadowOffsetY;\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {CoreLabelOptions} options\n * @returns {{width: number, height: number}}\n */\nfunction measureLabelSize(ctx, options) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    const size = {\n      width: getSize(content.width, options.width),\n      height: getSize(content.height, options.height)\n    };\n    return size;\n  }\n  const fonts = toFonts(options);\n  const strokeWidth = options.textStrokeWidth;\n  const lines = isArray(content) ? content : [content];\n  const mapKey = lines.join() + fontsKey(fonts) + strokeWidth + (ctx._measureText ? '-spriting' : '');\n  if (!widthCache.has(mapKey)) {\n    widthCache.set(mapKey, calculateLabelSize(ctx, lines, fonts, strokeWidth));\n  }\n  return widthCache.get(mapKey);\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {Object} options\n */\nfunction drawBox(ctx, rect, options) {\n  const {x, y, width, height} = rect;\n  ctx.save();\n  setShadowStyle(ctx, options);\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x, y, w: width, h: height,\n    radius: clampAll(toTRBLCorners(options.borderRadius), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n */\nfunction drawLabel(ctx, rect, options, fitRatio) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    ctx.save();\n    ctx.globalAlpha = getOpacity(options.opacity, content.style.opacity);\n    ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\n    ctx.restore();\n    return;\n  }\n  const labels = isArray(content) ? content : [content];\n  const fonts = toFonts(options, fitRatio);\n  const optColor = options.color;\n  const colors = isArray(optColor) ? optColor : [optColor];\n  const x = calculateTextAlignment(rect, options);\n  const y = rect.y + options.textStrokeWidth / 2;\n  ctx.save();\n  ctx.textBaseline = 'middle';\n  ctx.textAlign = options.textAlign;\n  if (setTextStrokeStyle(ctx, options)) {\n    applyLabelDecoration(ctx, {x, y}, labels, fonts);\n  }\n  applyLabelContent(ctx, {x, y}, labels, {fonts, colors});\n  ctx.restore();\n}\n\nfunction setTextStrokeStyle(ctx, options) {\n  if (options.textStrokeWidth > 0) {\n    // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\n    ctx.lineJoin = 'round';\n    ctx.miterLimit = 2;\n    ctx.lineWidth = options.textStrokeWidth;\n    ctx.strokeStyle = options.textStrokeColor;\n    return true;\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{radius: number, options: PointAnnotationOptions}} element\n * @param {number} x\n * @param {number} y\n */\nfunction drawPoint(ctx, element, x, y) {\n  const {radius, options} = element;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (isImageOrCanvas(style)) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(rad);\n    ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n    ctx.restore();\n    return;\n  }\n  if (notRadius(radius)) {\n    return;\n  }\n  drawPointStyle(ctx, {x, y, radius, rotation, style, rad});\n}\n\nfunction drawPointStyle(ctx, {x, y, radius, rotation, style, rad}) {\n  let xOffset, yOffset, size, cornerRadius;\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n  default:\n    ctx.arc(x, y, radius, 0, TAU);\n    ctx.closePath();\n    break;\n  case 'triangle':\n    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    ctx.closePath();\n    break;\n  case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n    cornerRadius = radius * 0.516;\n    size = radius - cornerRadius;\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\n    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n    ctx.closePath();\n    break;\n  case 'rect':\n    if (!rotation) {\n      size = Math.SQRT1_2 * radius;\n      ctx.rect(x - size, y - size, 2 * size, 2 * size);\n      break;\n    }\n    rad += QUARTER_PI;\n    /* falls through */\n  case 'rectRot':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    ctx.closePath();\n    break;\n  case 'crossRot':\n    rad += QUARTER_PI;\n    /* falls through */\n  case 'cross':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'star':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    rad += QUARTER_PI;\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'line':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    break;\n  case 'dash':\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n    break;\n  }\n\n  ctx.fill();\n}\n\nfunction calculateLabelSize(ctx, lines, fonts, strokeWidth) {\n  ctx.save();\n  const count = lines.length;\n  let width = 0;\n  let height = strokeWidth;\n  for (let i = 0; i < count; i++) {\n    const font = fonts[Math.min(i, fonts.length - 1)];\n    ctx.font = font.string;\n    const text = lines[i];\n    width = Math.max(width, ctx.measureText(text).width + strokeWidth);\n    height += font.lineHeight;\n  }\n  ctx.restore();\n  return {width, height};\n}\n\nfunction applyLabelDecoration(ctx, {x, y}, labels, fonts) {\n  ctx.beginPath();\n  let lhs = 0;\n  labels.forEach(function(l, i) {\n    const f = fonts[Math.min(i, fonts.length - 1)];\n    const lh = f.lineHeight;\n    ctx.font = f.string;\n    ctx.strokeText(l, x, y + lh / 2 + lhs);\n    lhs += lh;\n  });\n  ctx.stroke();\n}\n\nfunction applyLabelContent(ctx, {x, y}, labels, {fonts, colors}) {\n  let lhs = 0;\n  labels.forEach(function(l, i) {\n    const c = colors[Math.min(i, colors.length - 1)];\n    const f = fonts[Math.min(i, fonts.length - 1)];\n    const lh = f.lineHeight;\n    ctx.beginPath();\n    ctx.font = f.string;\n    ctx.fillStyle = c;\n    ctx.fillText(l, x, y + lh / 2 + lhs);\n    lhs += lh;\n    ctx.fill();\n  });\n}\n\nfunction getOpacity(value, elementValue) {\n  const opacity = isNumber(value) ? value : elementValue;\n  return isNumber(opacity) ? clamp(opacity, 0, 1) : 1;\n}\n\nconst positions = ['left', 'bottom', 'top', 'right'];\n\n/**\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\n/**\n * Drawa the callout component for labels.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {AnnotationElement} element - the label element\n */\nfunction drawCallout(ctx, element) {\n  const {pointX, pointY, options} = element;\n  const callout = options.callout;\n  const calloutPosition = callout && callout.display && resolveCalloutPosition(element, callout);\n  if (!calloutPosition || isPointInRange(element, callout, calloutPosition)) {\n    return;\n  }\n\n  ctx.save();\n  ctx.beginPath();\n  const stroke = setBorderStyle(ctx, callout);\n  if (!stroke) {\n    return ctx.restore();\n  }\n  const {separatorStart, separatorEnd} = getCalloutSeparatorCoord(element, calloutPosition);\n  const {sideStart, sideEnd} = getCalloutSideCoord(element, calloutPosition, separatorStart);\n  if (callout.margin > 0 || options.borderWidth === 0) {\n    ctx.moveTo(separatorStart.x, separatorStart.y);\n    ctx.lineTo(separatorEnd.x, separatorEnd.y);\n  }\n  ctx.moveTo(sideStart.x, sideStart.y);\n  ctx.lineTo(sideEnd.x, sideEnd.y);\n  const rotatedPoint = rotated({x: pointX, y: pointY}, element.getCenterPoint(), toRadians(-element.rotation));\n  ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction getCalloutSeparatorCoord(element, position) {\n  const {x, y, x2, y2} = element;\n  const adjust = getCalloutSeparatorAdjust(element, position);\n  let separatorStart, separatorEnd;\n  if (position === 'left' || position === 'right') {\n    separatorStart = {x: x + adjust, y};\n    separatorEnd = {x: separatorStart.x, y: y2};\n  } else {\n    //  position 'top' or 'bottom'\n    separatorStart = {x, y: y + adjust};\n    separatorEnd = {x: x2, y: separatorStart.y};\n  }\n  return {separatorStart, separatorEnd};\n}\n\nfunction getCalloutSeparatorAdjust(element, position) {\n  const {width, height, options} = element;\n  const adjust = options.callout.margin + options.borderWidth / 2;\n  if (position === 'right') {\n    return width + adjust;\n  } else if (position === 'bottom') {\n    return height + adjust;\n  }\n  return -adjust;\n}\n\nfunction getCalloutSideCoord(element, position, separatorStart) {\n  const {y, width, height, options} = element;\n  const start = options.callout.start;\n  const side = getCalloutSideAdjust(position, options.callout);\n  let sideStart, sideEnd;\n  if (position === 'left' || position === 'right') {\n    sideStart = {x: separatorStart.x, y: y + getSize(height, start)};\n    sideEnd = {x: sideStart.x + side, y: sideStart.y};\n  } else {\n    //  position 'top' or 'bottom'\n    sideStart = {x: separatorStart.x + getSize(width, start), y: separatorStart.y};\n    sideEnd = {x: sideStart.x, y: sideStart.y + side};\n  }\n  return {sideStart, sideEnd};\n}\n\nfunction getCalloutSideAdjust(position, options) {\n  const side = options.side;\n  if (position === 'left' || position === 'top') {\n    return -side;\n  }\n  return side;\n}\n\nfunction resolveCalloutPosition(element, options) {\n  const position = options.position;\n  if (positions.includes(position)) {\n    return position;\n  }\n  return resolveCalloutAutoPosition(element, options);\n}\n\nfunction resolveCalloutAutoPosition(element, options) {\n  const {x, y, x2, y2, width, height, pointX, pointY, centerX, centerY, rotation} = element;\n  const center = {x: centerX, y: centerY};\n  const start = options.start;\n  const xAdjust = getSize(width, start);\n  const yAdjust = getSize(height, start);\n  const xPoints = [x, x + xAdjust, x + xAdjust, x2];\n  const yPoints = [y + yAdjust, y2, y, y2];\n  const result = [];\n  for (let index = 0; index < 4; index++) {\n    const rotatedPoint = rotated({x: xPoints[index], y: yPoints[index]}, center, toRadians(rotation));\n    result.push({\n      position: positions[index],\n      distance: distanceBetweenPoints(rotatedPoint, {x: pointX, y: pointY})\n    });\n  }\n  return result.sort((a, b) => a.distance - b.distance)[0].position;\n}\n\nfunction isPointInRange(element, callout, position) {\n  const {pointX, pointY} = element;\n  const margin = callout.margin;\n  let x = pointX;\n  let y = pointY;\n  if (position === 'left') {\n    x += margin;\n  } else if (position === 'right') {\n    x -= margin;\n  } else if (position === 'top') {\n    y += margin;\n  } else if (position === 'bottom') {\n    y -= margin;\n  }\n  return element.inRange(x, y);\n}\n\nconst limitedLineScale = {\n  xScaleID: {min: 'xMin', max: 'xMax', start: 'left', end: 'right', startProp: 'x', endProp: 'x2'},\n  yScaleID: {min: 'yMin', max: 'yMax', start: 'bottom', end: 'top', startProp: 'y', endProp: 'y2'}\n};\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import(\"chart.js\").Point } Point\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n * @typedef { import('../../types/options').LineAnnotationOptions } LineAnnotationOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n * @typedef { import('../../types/options').PolygonAnnotationOptions } PolygonAnnotationOptions\n */\n\n/**\n * @param {Scale} scale\n * @param {number|string} value\n * @param {number} fallback\n * @returns {number}\n */\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\n * Search the scale defined in chartjs by the axis related to the annotation options key.\n * @param {{ [key: string]: Scale }} scales\n * @param {CoreAnnotationOptions} options\n * @param {string} key\n * @returns {string}\n */\nfunction retrieveScaleID(scales, options, key) {\n  const scaleID = options[key];\n  if (scaleID || key === 'scaleID') {\n    return scaleID;\n  }\n  const axis = key.charAt(0);\n  const axes = Object.values(scales).filter((scale) => scale.axis && scale.axis === axis);\n  if (axes.length) {\n    return axes[0].id;\n  }\n  return axis;\n}\n\n/**\n * @param {Scale} scale\n * @param {{min: number, max: number, start: number, end: number}} options\n * @returns {{start: number, end: number}|undefined}\n */\nfunction getDimensionByScale(scale, options) {\n  if (scale) {\n    const reverse = scale.options.reverse;\n    const start = scaleValue(scale, options.min, reverse ? options.end : options.start);\n    const end = scaleValue(scale, options.max, reverse ? options.start : options.end);\n    return {\n      start,\n      end\n    };\n  }\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {Point}\n */\nfunction getChartPoint(chart, options) {\n  const {chartArea, scales} = chart;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n  let x = chartArea.width / 2;\n  let y = chartArea.height / 2;\n\n  if (xScale) {\n    x = scaleValue(xScale, options.xValue, xScale.left + xScale.width / 2);\n  }\n\n  if (yScale) {\n    y = scaleValue(yScale, options.yValue, yScale.top + yScale.height / 2);\n  }\n  return {x, y};\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolveBoxProperties(chart, options) {\n  const scales = chart.scales;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n\n  if (!xScale && !yScale) {\n    return {};\n  }\n\n  let {left: x, right: x2} = xScale || chart.chartArea;\n  let {top: y, bottom: y2} = yScale || chart.chartArea;\n  const xDim = getChartDimensionByScale(xScale, {min: options.xMin, max: options.xMax, start: x, end: x2});\n  x = xDim.start;\n  x2 = xDim.end;\n  const yDim = getChartDimensionByScale(yScale, {min: options.yMin, max: options.yMax, start: y2, end: y});\n  y = yDim.start;\n  y2 = yDim.end;\n\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: x2 - x,\n    height: y2 - y,\n    centerX: x + (x2 - x) / 2,\n    centerY: y + (y2 - y) / 2\n  };\n}\n\n/**\n * @param {Chart} chart\n * @param {PointAnnotationOptions|PolygonAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolvePointProperties(chart, options) {\n  if (!isBoundToPoint(options)) {\n    const box = resolveBoxProperties(chart, options);\n    let radius = options.radius;\n    if (!radius || isNaN(radius)) {\n      radius = Math.min(box.width, box.height) / 2;\n      options.radius = radius;\n    }\n    const size = radius * 2;\n    const adjustCenterX = box.centerX + options.xAdjust;\n    const adjustCenterY = box.centerY + options.yAdjust;\n    return {\n      x: adjustCenterX - radius,\n      y: adjustCenterY - radius,\n      x2: adjustCenterX + radius,\n      y2: adjustCenterY + radius,\n      centerX: adjustCenterX,\n      centerY: adjustCenterY,\n      width: size,\n      height: size,\n      radius\n    };\n  }\n  return getChartCircle(chart, options);\n}\n/**\n * @param {Chart} chart\n * @param {LineAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolveLineProperties(chart, options) {\n  const {scales, chartArea} = chart;\n  const scale = scales[options.scaleID];\n  const area = {x: chartArea.left, y: chartArea.top, x2: chartArea.right, y2: chartArea.bottom};\n\n  if (scale) {\n    resolveFullLineProperties(scale, area, options);\n  } else {\n    resolveLimitedLineProperties(scales, area, options);\n  }\n  return area;\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @param {boolean} [centerBased=false]\n * @returns {AnnotationBoxModel}\n */\nfunction resolveBoxAndLabelProperties(chart, options) {\n  const properties = resolveBoxProperties(chart, options);\n  properties.initProperties = initAnimationProperties(chart, properties, options);\n  properties.elements = [{\n    type: 'label',\n    optionScope: 'label',\n    properties: resolveLabelElementProperties$1(chart, properties, options),\n    initProperties: properties.initProperties\n  }];\n  return properties;\n}\n\nfunction getChartCircle(chart, options) {\n  const point = getChartPoint(chart, options);\n  const size = options.radius * 2;\n  return {\n    x: point.x - options.radius + options.xAdjust,\n    y: point.y - options.radius + options.yAdjust,\n    x2: point.x + options.radius + options.xAdjust,\n    y2: point.y + options.radius + options.yAdjust,\n    centerX: point.x + options.xAdjust,\n    centerY: point.y + options.yAdjust,\n    radius: options.radius,\n    width: size,\n    height: size\n  };\n}\n\nfunction getChartDimensionByScale(scale, options) {\n  const result = getDimensionByScale(scale, options) || options;\n  return {\n    start: Math.min(result.start, result.end),\n    end: Math.max(result.start, result.end)\n  };\n}\n\nfunction resolveFullLineProperties(scale, area, options) {\n  const min = scaleValue(scale, options.value, NaN);\n  const max = scaleValue(scale, options.endValue, min);\n  if (scale.isHorizontal()) {\n    area.x = min;\n    area.x2 = max;\n  } else {\n    area.y = min;\n    area.y2 = max;\n  }\n}\n\nfunction resolveLimitedLineProperties(scales, area, options) {\n  for (const scaleId of Object.keys(limitedLineScale)) {\n    const scale = scales[retrieveScaleID(scales, options, scaleId)];\n    if (scale) {\n      const {min, max, start, end, startProp, endProp} = limitedLineScale[scaleId];\n      const dim = getDimensionByScale(scale, {min: options[min], max: options[max], start: scale[start], end: scale[end]});\n      area[startProp] = dim.start;\n      area[endProp] = dim.end;\n    }\n  }\n}\n\nfunction calculateX({properties, options}, labelSize, position, padding) {\n  const {x: start, x2: end, width: size} = properties;\n  return calculatePosition({start, end, size, borderWidth: options.borderWidth}, {\n    position: position.x,\n    padding: {start: padding.left, end: padding.right},\n    adjust: options.label.xAdjust,\n    size: labelSize.width\n  });\n}\n\nfunction calculateY({properties, options}, labelSize, position, padding) {\n  const {y: start, y2: end, height: size} = properties;\n  return calculatePosition({start, end, size, borderWidth: options.borderWidth}, {\n    position: position.y,\n    padding: {start: padding.top, end: padding.bottom},\n    adjust: options.label.yAdjust,\n    size: labelSize.height\n  });\n}\n\nfunction calculatePosition(boxOpts, labelOpts) {\n  const {start, end, borderWidth} = boxOpts;\n  const {position, padding: {start: padStart, end: padEnd}, adjust} = labelOpts;\n  const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\n  return start + borderWidth / 2 + adjust + getRelativePosition(availableSize, position);\n}\n\nfunction resolveLabelElementProperties$1(chart, properties, options) {\n  const label = options.label;\n  label.backgroundColor = 'transparent';\n  label.callout.display = false;\n  const position = toPosition(label.position);\n  const padding = toPadding(label.padding);\n  const labelSize = measureLabelSize(chart.ctx, label);\n  const x = calculateX({properties, options}, labelSize, position, padding);\n  const y = calculateY({properties, options}, labelSize, position, padding);\n  const width = labelSize.width + padding.width;\n  const height = labelSize.height + padding.height;\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2,\n    rotation: label.rotation\n  };\n\n}\n\nconst moveHooks = ['enter', 'leave'];\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */\n\nconst eventHooks = moveHooks.concat('click');\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n */\nfunction updateListeners(chart, state, options) {\n  state.listened = loadHooks(options, eventHooks, state.listeners);\n  state.moveListened = false;\n\n  moveHooks.forEach(hook => {\n    if (isFunction(options[hook])) {\n      state.moveListened = true;\n    }\n  });\n\n  if (!state.listened || !state.moveListened) {\n    state.annotations.forEach(scope => {\n      if (!state.listened && isFunction(scope.click)) {\n        state.listened = true;\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (isFunction(scope[hook])) {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\n * @param {Object} state\n * @param {ChartEvent} event\n * @param {AnnotationPluginOptions} options\n * @return {boolean|undefined}\n */\nfunction handleEvent(state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n    case 'mousemove':\n    case 'mouseout':\n      return handleMoveEvents(state, event, options);\n    case 'click':\n      return handleClickEvents(state, event, options);\n    }\n  }\n}\n\nfunction handleMoveEvents(state, event, options) {\n  if (!state.moveListened) {\n    return;\n  }\n\n  let elements;\n\n  if (event.type === 'mousemove') {\n    elements = getElements(state.visibleElements, event, options.interaction);\n  } else {\n    elements = [];\n  }\n\n  const previous = state.hovered;\n  state.hovered = elements;\n\n  const context = {state, event};\n  let changed = dispatchMoveEvents(context, 'leave', previous, elements);\n  return dispatchMoveEvents(context, 'enter', elements, previous) || changed;\n}\n\nfunction dispatchMoveEvents({state, event}, hook, elements, checkElements) {\n  let changed;\n  for (const element of elements) {\n    if (checkElements.indexOf(element) < 0) {\n      changed = dispatchEvent(element.options[hook] || state.listeners[hook], element, event) || changed;\n    }\n  }\n  return changed;\n}\n\nfunction handleClickEvents(state, event, options) {\n  const listeners = state.listeners;\n  const elements = getElements(state.visibleElements, event, options.interaction);\n  let changed;\n  for (const element of elements) {\n    changed = dispatchEvent(element.options.click || listeners.click, element, event) || changed;\n  }\n  return changed;\n}\n\nfunction dispatchEvent(handler, element, event) {\n  return callback(handler, [element.$context, event]) === true;\n}\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst elementHooks = ['afterDraw', 'beforeDraw'];\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n */\nfunction updateHooks(chart, state, options) {\n  const visibleElements = state.visibleElements;\n  state.hooked = loadHooks(options, elementHooks, state.hooks);\n\n  if (!state.hooked) {\n    visibleElements.forEach(scope => {\n      if (!state.hooked) {\n        elementHooks.forEach(hook => {\n          if (isFunction(scope.options[hook])) {\n            state.hooked = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\n * @param {Object} state\n * @param {AnnotationElement} element\n * @param {string} hook\n */\nfunction invokeHook(state, element, hook) {\n  if (state.hooked) {\n    const callbackHook = element.options[hook] || state.hooks[hook];\n    return callback(callbackHook, [element.$context]);\n  }\n}\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n */\n\n/**\n * @param {Chart} chart\n * @param {Scale} scale\n * @param {CoreAnnotationOptions[]} annotations\n */\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(chart.scales, scale, annotations);\n  let changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');\n  changed = changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;\n  if (changed && isFunction(scale.handleTickRangeOptions)) {\n    scale.handleTickRangeOptions();\n  }\n}\n\n/**\n * @param {CoreAnnotationOptions[]} annotations\n * @param {{ [key: string]: Scale }} scales\n */\nfunction verifyScaleOptions(annotations, scales) {\n  for (const annotation of annotations) {\n    verifyScaleIDs(annotation, scales);\n  }\n}\n\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\n  if (isFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\n    const changed = scale[limit] !== range[limit];\n    scale[limit] = range[limit];\n    return changed;\n  }\n}\n\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\n  return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);\n}\n\nfunction verifyScaleIDs(annotation, scales) {\n  for (const key of ['scaleID', 'xScaleID', 'yScaleID']) {\n    const scaleID = retrieveScaleID(scales, annotation, key);\n    if (scaleID && !scales[scaleID] && verifyProperties(annotation, key)) {\n      console.warn(`No scale found with id '${scaleID}' for annotation '${annotation.id}'`);\n    }\n  }\n}\n\nfunction verifyProperties(annotation, key) {\n  if (key === 'scaleID') {\n    return true;\n  }\n  const axis = key.charAt(0);\n  for (const prop of ['Min', 'Max', 'Value']) {\n    if (defined(annotation[axis + prop])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getScaleLimits(scales, scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  const limits = {\n    min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),\n    max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)\n  };\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      updateLimits(annotation, scale, ['value', 'endValue'], limits);\n    } else if (retrieveScaleID(scales, annotation, scaleIDOption) === scaleID) {\n      updateLimits(annotation, scale, [axis + 'Min', axis + 'Max', axis + 'Value'], limits);\n    }\n  }\n  return limits;\n}\n\nfunction updateLimits(annotation, scale, props, limits) {\n  for (const prop of props) {\n    const raw = annotation[prop];\n    if (defined(raw)) {\n      const value = scale.parse(raw);\n      limits.min = Math.min(limits.min, value);\n      limits.max = Math.max(limits.max, value);\n    }\n  }\n}\n\nclass BoxAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {x, y} = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    return inBoxRange({x, y}, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.options.rotation);\n    drawBox(ctx, this, this.options);\n    ctx.restore();\n  }\n\n  get label() {\n    return this.elements && this.elements[0];\n  }\n\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n}\n\nBoxAnnotation.id = 'boxAnnotation';\n\nBoxAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  init: undefined,\n  hitTolerance: 0,\n  label: {\n    backgroundColor: 'transparent',\n    borderWidth: 0,\n    callout: {\n      display: false\n    },\n    color: 'black',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    hitTolerance: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: undefined,\n    textAlign: 'start',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\n\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nBoxAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\n\nclass DoughnutLabelAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    return inLabelRange(\n      {x: mouseX, y: mouseY},\n      {rect: this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), center: this.getCenterPoint(useFinalPosition)},\n      axis,\n      {rotation: this.rotation, borderWidth: 0, hitTolerance: this.options.hitTolerance}\n    );\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    if (!options.display || !options.content) {\n      return;\n    }\n    drawBackground(ctx, this);\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.rotation);\n    drawLabel(ctx, this, options, this._fitRatio);\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const meta = getDatasetMeta(chart, options);\n    if (!meta) {\n      return {};\n    }\n    const {controllerMeta, point, radius} = getControllerMeta(chart, options, meta);\n    let labelSize = measureLabelSize(chart.ctx, options);\n    const _fitRatio = getFitRatio(labelSize, radius);\n    if (shouldFit(options, _fitRatio)) {\n      labelSize = {width: labelSize.width * _fitRatio, height: labelSize.height * _fitRatio};\n    }\n    const {position, xAdjust, yAdjust} = options;\n    const boxSize = measureLabelRectangle(point, labelSize, {borderWidth: 0, position, xAdjust, yAdjust});\n    return {\n      initProperties: initAnimationProperties(chart, boxSize, options),\n      ...boxSize,\n      ...controllerMeta,\n      rotation: options.rotation,\n      _fitRatio\n    };\n  }\n}\n\nDoughnutLabelAnnotation.id = 'doughnutLabelAnnotation';\n\nDoughnutLabelAnnotation.defaults = {\n  autoFit: true,\n  autoHide: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  hitTolerance: 0,\n  init: undefined,\n  opacity: undefined,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  spacing: 1,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  yAdjust: 0\n};\n\nDoughnutLabelAnnotation.defaultRoutes = {\n};\n\nfunction getDatasetMeta(chart, options) {\n  return chart.getSortedVisibleDatasetMetas().reduce(function(result, value) {\n    const controller = value.controller;\n    if (controller instanceof DoughnutController &&\n      isControllerVisible(chart, options, value.data) &&\n      (!result || controller.innerRadius < result.controller.innerRadius) &&\n      controller.options.circumference >= 90) {\n      return value;\n    }\n    return result;\n  }, undefined);\n}\n\nfunction isControllerVisible(chart, options, elements) {\n  if (!options.autoHide) {\n    return true;\n  }\n  for (let i = 0; i < elements.length; i++) {\n    if (!elements[i].hidden && chart.getDataVisibility(i)) {\n      return true;\n    }\n  }\n}\n\nfunction getControllerMeta({chartArea}, options, meta) {\n  const {left, top, right, bottom} = chartArea;\n  const {innerRadius, offsetX, offsetY} = meta.controller;\n  const x = (left + right) / 2 + offsetX;\n  const y = (top + bottom) / 2 + offsetY;\n  const square = {\n    left: Math.max(x - innerRadius, left),\n    right: Math.min(x + innerRadius, right),\n    top: Math.max(y - innerRadius, top),\n    bottom: Math.min(y + innerRadius, bottom)\n  };\n  const point = {\n    x: (square.left + square.right) / 2,\n    y: (square.top + square.bottom) / 2\n  };\n  const space = options.spacing + options.borderWidth / 2;\n  const _radius = innerRadius - space;\n  const _counterclockwise = point.y > y;\n  const side = _counterclockwise ? top + space : bottom - space;\n  const angles = getAngles(side, x, y, _radius);\n  const controllerMeta = {\n    _centerX: x,\n    _centerY: y,\n    _radius,\n    _counterclockwise,\n    ...angles\n  };\n  return {\n    controllerMeta,\n    point,\n    radius: Math.min(innerRadius, Math.min(square.right - square.left, square.bottom - square.top) / 2)\n  };\n}\n\nfunction getFitRatio({width, height}, radius) {\n  const hypo = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n  return (radius * 2) / hypo;\n}\n\nfunction getAngles(y, centerX, centerY, radius) {\n  const yk2 = Math.pow(centerY - y, 2);\n  const r2 = Math.pow(radius, 2);\n  const b = centerX * -2;\n  const c = Math.pow(centerX, 2) + yk2 - r2;\n  const delta = Math.pow(b, 2) - (4 * c);\n  if (delta <= 0) {\n    return {\n      _startAngle: 0,\n      _endAngle: TAU\n    };\n  }\n  const start = (-b - Math.sqrt(delta)) / 2;\n  const end = (-b + Math.sqrt(delta)) / 2;\n  return {\n    _startAngle: getAngleFromPoint({x: centerX, y: centerY}, {x: start, y}).angle,\n    _endAngle: getAngleFromPoint({x: centerX, y: centerY}, {x: end, y}).angle\n  };\n}\n\nfunction drawBackground(ctx, element) {\n  const {_centerX, _centerY, _radius, _startAngle, _endAngle, _counterclockwise, options} = element;\n  ctx.save();\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  ctx.arc(_centerX, _centerY, _radius, _startAngle, _endAngle, _counterclockwise);\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\nclass LabelAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    return inLabelRange(\n      {x: mouseX, y: mouseY},\n      {rect: this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), center: this.getCenterPoint(useFinalPosition)},\n      axis,\n      {rotation: this.rotation, borderWidth: this.options.borderWidth, hitTolerance: this.options.hitTolerance}\n    );\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    const visible = !defined(this._visible) || this._visible;\n    if (!options.display || !options.content || !visible) {\n      return;\n    }\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.rotation);\n    drawCallout(ctx, this);\n    drawBox(ctx, this, options);\n    drawLabel(ctx, getLabelSize(this), options);\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    let point;\n    if (!isBoundToPoint(options)) {\n      const {centerX, centerY} = resolveBoxProperties(chart, options);\n      point = {x: centerX, y: centerY};\n    } else {\n      point = getChartPoint(chart, options);\n    }\n    const padding = toPadding(options.padding);\n    const labelSize = measureLabelSize(chart.ctx, options);\n    const boxSize = measureLabelRectangle(point, labelSize, options, padding);\n    return {\n      initProperties: initAnimationProperties(chart, boxSize, options),\n      pointX: point.x,\n      pointY: point.y,\n      ...boxSize,\n      rotation: options.rotation\n    };\n  }\n}\n\nLabelAnnotation.id = 'labelAnnotation';\n\nLabelAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  callout: {\n    borderCapStyle: 'butt',\n    borderColor: undefined,\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 1,\n    display: false,\n    margin: 5,\n    position: 'auto',\n    side: 5,\n    start: '50%',\n  },\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  hitTolerance: 0,\n  init: undefined,\n  opacity: undefined,\n  padding: 6,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\n\nLabelAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction getLabelSize({x, y, width, height, options}) {\n  const hBorderWidth = options.borderWidth / 2;\n  const padding = toPadding(options.padding);\n  return {\n    x: x + padding.left + hBorderWidth,\n    y: y + padding.top + hBorderWidth,\n    width: width - padding.left - padding.right - options.borderWidth,\n    height: height - padding.top - padding.bottom - options.borderWidth\n  };\n}\n\nconst pointInLine = (p1, p2, t) => ({x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y)});\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst sqr = v => v * v;\nconst rangeLimit = (mouseX, mouseY, {x, y, x2, y2}, axis) => axis === 'y' ? {start: Math.min(y, y2), end: Math.max(y, y2), value: mouseY} : {start: Math.min(x, x2), end: Math.max(x, x2), value: mouseX};\n// http://www.independent-software.com/determining-coordinates-on-a-html-canvas-bezier-curve.html\nconst coordInCurve = (start, cp, end, t) => (1 - t) * (1 - t) * start + 2 * (1 - t) * t * cp + t * t * end;\nconst pointInCurve = (start, cp, end, t) => ({x: coordInCurve(start.x, cp.x, end.x, t), y: coordInCurve(start.y, cp.y, end.y, t)});\nconst coordAngleInCurve = (start, cp, end, t) => 2 * (1 - t) * (cp - start) + 2 * t * (end - cp);\nconst angleInCurve = (start, cp, end, t) => -Math.atan2(coordAngleInCurve(start.x, cp.x, end.x, t), coordAngleInCurve(start.y, cp.y, end.y, t)) + 0.5 * PI;\n\nclass LineAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      const point = {mouseX, mouseY};\n      const {path, ctx} = this;\n      if (path) {\n        setBorderStyle(ctx, this.options);\n        ctx.lineWidth += this.options.hitTolerance;\n        const {chart} = this.$context;\n        const mx = mouseX * chart.currentDevicePixelRatio;\n        const my = mouseY * chart.currentDevicePixelRatio;\n        const result = ctx.isPointInStroke(path, mx, my) || isOnLabel(this, point, useFinalPosition);\n        ctx.restore();\n        return result;\n      }\n      const epsilon = sqr(hitSize);\n      return intersects(this, point, epsilon, useFinalPosition) || isOnLabel(this, point, useFinalPosition);\n    }\n    return inAxisRange(this, {mouseX, mouseY}, axis, {hitSize, useFinalPosition});\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {x, y, x2, y2, cp, options} = this;\n\n    ctx.save();\n    if (!setBorderStyle(ctx, options)) {\n      // no border width, then line is not drawn\n      return ctx.restore();\n    }\n    setShadowStyle(ctx, options);\n\n    const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\n    if (options.curve && cp) {\n      drawCurve(ctx, this, cp, length);\n      return ctx.restore();\n    }\n    const {startOpts, endOpts, startAdjust, endAdjust} = getArrowHeads(this);\n    const angle = Math.atan2(y2 - y, x2 - x);\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(0 + startAdjust, 0);\n    ctx.lineTo(length - endAdjust, 0);\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n    drawArrowHead(ctx, 0, startAdjust, startOpts);\n    drawArrowHead(ctx, length, -endAdjust, endOpts);\n    ctx.restore();\n  }\n\n  get label() {\n    return this.elements && this.elements[0];\n  }\n\n  resolveElementProperties(chart, options) {\n    const area = resolveLineProperties(chart, options);\n    const {x, y, x2, y2} = area;\n    const inside = isLineInArea(area, chart.chartArea);\n    const properties = inside\n      ? limitLineToArea({x, y}, {x: x2, y: y2}, chart.chartArea)\n      : {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n    properties.centerX = (x2 + x) / 2;\n    properties.centerY = (y2 + y) / 2;\n    properties.initProperties = initAnimationProperties(chart, properties, options);\n    if (options.curve) {\n      const p1 = {x: properties.x, y: properties.y};\n      const p2 = {x: properties.x2, y: properties.y2};\n      properties.cp = getControlPoint(properties, options, distanceBetweenPoints(p1, p2));\n    }\n    const labelProperties = resolveLabelElementProperties(chart, properties, options.label);\n    // additonal prop to manage zoom/pan\n    labelProperties._visible = inside;\n\n    properties.elements = [{\n      type: 'label',\n      optionScope: 'label',\n      properties: labelProperties,\n      initProperties: properties.initProperties\n    }];\n    return properties;\n  }\n}\n\nLineAnnotation.id = 'lineAnnotation';\n\nconst arrowHeadsDefaults = {\n  backgroundColor: undefined,\n  backgroundShadowColor: undefined,\n  borderColor: undefined,\n  borderDash: undefined,\n  borderDashOffset: undefined,\n  borderShadowColor: undefined,\n  borderWidth: undefined,\n  display: undefined,\n  fill: undefined,\n  length: undefined,\n  shadowBlur: undefined,\n  shadowOffsetX: undefined,\n  shadowOffsetY: undefined,\n  width: undefined\n};\n\nLineAnnotation.defaults = {\n  adjustScaleRange: true,\n  arrowHeads: {\n    display: false,\n    end: Object.assign({}, arrowHeadsDefaults),\n    fill: false,\n    length: 12,\n    start: Object.assign({}, arrowHeadsDefaults),\n    width: 6\n  },\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 2,\n  curve: false,\n  controlPoint: {\n    y: '-50%'\n  },\n  display: true,\n  endValue: undefined,\n  init: undefined,\n  hitTolerance: 0,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    backgroundShadowColor: 'transparent',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderShadowColor: 'transparent',\n    borderWidth: 0,\n    callout: Object.assign({}, LabelAnnotation.defaults.callout),\n    color: '#fff',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    hitTolerance: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    textAlign: 'center',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  scaleID: undefined,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  value: undefined,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\n\nLineAnnotation.descriptors = {\n  arrowHeads: {\n    start: {\n      _fallback: true\n    },\n    end: {\n      _fallback: true\n    },\n    _fallback: true\n  }\n};\n\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction inAxisRange(element, {mouseX, mouseY}, axis, {hitSize, useFinalPosition}) {\n  const limit = rangeLimit(mouseX, mouseY, element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis);\n  return inLimit(limit, hitSize) || isOnLabel(element, {mouseX, mouseY}, useFinalPosition, axis);\n}\n\nfunction isLineInArea({x, y, x2, y2}, {top, right, bottom, left}) {\n  return !(\n    (x < left && x2 < left) ||\n    (x > right && x2 > right) ||\n    (y < top && y2 < top) ||\n    (y > bottom && y2 > bottom)\n  );\n}\n\nfunction limitPointToArea({x, y}, p2, {top, right, bottom, left}) {\n  if (x < left) {\n    y = interpolateY(left, {x, y}, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = interpolateY(right, {x, y}, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = interpolateX(top, {x, y}, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = interpolateX(bottom, {x, y}, p2);\n    y = bottom;\n  }\n  return {x, y};\n}\n\nfunction limitLineToArea(p1, p2, area) {\n  const {x, y} = limitPointToArea(p1, p2, area);\n  const {x: x2, y: y2} = limitPointToArea(p2, p1, area);\n  return {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n}\n\nfunction intersects(element, {mouseX, mouseY}, epsilon = EPSILON, useFinalPosition) {\n  // Adapted from https://stackoverflow.com/a/6853926/25507\n  const {x: x1, y: y1, x2, y2} = element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lenSq = sqr(dx) + sqr(dy);\n  const t = lenSq === 0 ? -1 : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;\n\n  let xx, yy;\n  if (t < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (t > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + t * dx;\n    yy = y1 + t * dy;\n  }\n  return (sqr(mouseX - xx) + sqr(mouseY - yy)) <= epsilon;\n}\n\nfunction isOnLabel(element, {mouseX, mouseY}, useFinalPosition, axis) {\n  const label = element.label;\n  return label.options.display && label.inRange(mouseX, mouseY, axis, useFinalPosition);\n}\n\nfunction resolveLabelElementProperties(chart, properties, options) {\n  const borderWidth = options.borderWidth;\n  const padding = toPadding(options.padding);\n  const textSize = measureLabelSize(chart.ctx, options);\n  const width = textSize.width + padding.width + borderWidth;\n  const height = textSize.height + padding.height + borderWidth;\n  return calculateLabelPosition(properties, options, {width, height, padding}, chart.chartArea);\n}\n\nfunction calculateAutoRotation(properties) {\n  const {x, y, x2, y2} = properties;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\n\nfunction calculateLabelPosition(properties, label, sizes, chartArea) {\n  const {width, height, padding} = sizes;\n  const {xAdjust, yAdjust} = label;\n  const p1 = {x: properties.x, y: properties.y};\n  const p2 = {x: properties.x2, y: properties.y2};\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(properties) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(properties, label, {labelSize: size, padding}, chartArea);\n  const pt = properties.cp ? pointInCurve(p1, properties.cp, p2, t) : pointInLine(p1, p2, t);\n  const xCoordinateSizes = {size: size.w, min: chartArea.left, max: chartArea.right, padding: padding.left};\n  const yCoordinateSizes = {size: size.h, min: chartArea.top, max: chartArea.bottom, padding: padding.top};\n  const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;\n  const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;\n  return {\n    x: centerX - (width / 2),\n    y: centerY - (height / 2),\n    x2: centerX + (width / 2),\n    y2: centerY + (height / 2),\n    centerX,\n    centerY,\n    pointX: pt.x,\n    pointY: pt.y,\n    width,\n    height,\n    rotation: toDegrees(rotation)\n  };\n}\n\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\n\nfunction calculateT(properties, label, sizes, chartArea) {\n  let t;\n  const space = spaceAround(properties, chartArea);\n  if (label.position === 'start') {\n    t = calculateTAdjust({w: properties.x2 - properties.x, h: properties.y2 - properties.y}, sizes, label, space);\n  } else if (label.position === 'end') {\n    t = 1 - calculateTAdjust({w: properties.x - properties.x2, h: properties.y - properties.y2}, sizes, label, space);\n  } else {\n    t = getRelativePosition(1, label.position);\n  }\n  return t;\n}\n\nfunction calculateTAdjust(lineSize, sizes, label, space) {\n  const {labelSize, padding} = sizes;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = (lineW > 0) && ((labelSize.w / 2 + padding.left - space.x) / lineW);\n  const y = (lineH > 0) && ((labelSize.h / 2 + padding.top - space.y) / lineH);\n  return clamp(Math.max(x, y), 0, 0.25);\n}\n\nfunction spaceAround(properties, chartArea) {\n  const {x, x2, y, y2} = properties;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l <= r ? 1 : -1,\n    dy: t <= b ? 1 : -1\n  };\n}\n\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {size, min, max, padding} = labelSizes;\n  const halfSize = size / 2;\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n  if (min >= (coordinate - padding - halfSize)) {\n    coordinate = min + padding + halfSize;\n  }\n  if (max <= (coordinate + padding + halfSize)) {\n    coordinate = max - padding - halfSize;\n  }\n  return coordinate;\n}\n\nfunction getArrowHeads(line) {\n  const options = line.options;\n  const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\n  const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\n  return {\n    startOpts: arrowStartOpts,\n    endOpts: arrowEndOpts,\n    startAdjust: getLineAdjust(line, arrowStartOpts),\n    endAdjust: getLineAdjust(line, arrowEndOpts)\n  };\n}\n\nfunction getLineAdjust(line, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return 0;\n  }\n  const {length, width} = arrowOpts;\n  const adjust = line.options.borderWidth / 2;\n  const p1 = {x: length, y: width + adjust};\n  const p2 = {x: 0, y: adjust};\n  return Math.abs(interpolateX(0, p1, p2));\n}\n\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  const {length, width, fill, backgroundColor, borderColor} = arrowOpts;\n  const arrowOffsetX = Math.abs(offset - length) + adjust;\n  ctx.beginPath();\n  setShadowStyle(ctx, arrowOpts);\n  setBorderStyle(ctx, arrowOpts);\n  ctx.moveTo(arrowOffsetX, -width);\n  ctx.lineTo(offset + adjust, 0);\n  ctx.lineTo(arrowOffsetX, width);\n  if (fill === true) {\n    ctx.fillStyle = backgroundColor || borderColor;\n    ctx.closePath();\n    ctx.fill();\n    ctx.shadowColor = 'transparent';\n  } else {\n    ctx.shadowColor = arrowOpts.borderShadowColor;\n  }\n  ctx.stroke();\n}\n\nfunction getControlPoint(properties, options, distance) {\n  const {x, y, x2, y2, centerX, centerY} = properties;\n  const angle = Math.atan2(y2 - y, x2 - x);\n  const cp = toPosition(options.controlPoint, 0);\n  const point = {\n    x: centerX + getSize(distance, cp.x, false),\n    y: centerY + getSize(distance, cp.y, false)\n  };\n  return rotated(point, {x: centerX, y: centerY}, angle);\n}\n\nfunction drawArrowHeadOnCurve(ctx, {x, y}, {angle, adjust}, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  ctx.save();\n  ctx.translate(x, y);\n  ctx.rotate(angle);\n  drawArrowHead(ctx, 0, -adjust, arrowOpts);\n  ctx.restore();\n}\n\nfunction drawCurve(ctx, element, cp, length) {\n  const {x, y, x2, y2, options} = element;\n  const {startOpts, endOpts, startAdjust, endAdjust} = getArrowHeads(element);\n  const p1 = {x, y};\n  const p2 = {x: x2, y: y2};\n  const startAngle = angleInCurve(p1, cp, p2, 0);\n  const endAngle = angleInCurve(p1, cp, p2, 1) - PI;\n  const ps = pointInCurve(p1, cp, p2, startAdjust / length);\n  const pe = pointInCurve(p1, cp, p2, 1 - endAdjust / length);\n\n  const path = new Path2D();\n  ctx.beginPath();\n  path.moveTo(ps.x, ps.y);\n  path.quadraticCurveTo(cp.x, cp.y, pe.x, pe.y);\n  ctx.shadowColor = options.borderShadowColor;\n  ctx.stroke(path);\n  element.path = path;\n  element.ctx = ctx;\n  drawArrowHeadOnCurve(ctx, ps, {angle: startAngle, adjust: startAdjust}, startOpts);\n  drawArrowHeadOnCurve(ctx, pe, {angle: endAngle, adjust: endAdjust}, endOpts);\n}\n\nclass EllipseAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const rotation = this.options.rotation;\n    const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      return pointInEllipse({x: mouseX, y: mouseY}, this.getProps(['width', 'height', 'centerX', 'centerY'], useFinalPosition), rotation, hitSize);\n    }\n    const {x, y, x2, y2} = this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n    const limit = axis === 'y' ? {start: y, end: y2} : {start: x, end: x2};\n    const rotatedPoint = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-rotation));\n    return rotatedPoint[axis] >= limit.start - hitSize - EPSILON && rotatedPoint[axis] <= limit.end + hitSize + EPSILON;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {width, height, centerX, centerY, options} = this;\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), options.rotation);\n    setShadowStyle(ctx, this.options);\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    const stroke = setBorderStyle(ctx, options);\n    ctx.ellipse(centerX, centerY, height / 2, width / 2, PI / 2, 0, 2 * PI);\n    ctx.fill();\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  get label() {\n    return this.elements && this.elements[0];\n  }\n\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n\n}\n\nEllipseAnnotation.id = 'ellipseAnnotation';\n\nEllipseAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  hitTolerance: 0,\n  init: undefined,\n  label: Object.assign({}, BoxAnnotation.defaults.label),\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\n\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nEllipseAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\n\nfunction pointInEllipse(p, ellipse, rotation, hitSize) {\n  const {width, height, centerX, centerY} = ellipse;\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n  // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\n  const angle = toRadians(rotation || 0);\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const a = Math.pow(cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY), 2);\n  const b = Math.pow(sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY), 2);\n  return (a / Math.pow(xRadius + hitSize, 2)) + (b / Math.pow(yRadius + hitSize, 2)) <= 1.0001;\n}\n\nclass PointAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {x, y, x2, y2, width} = this.getProps(['x', 'y', 'x2', 'y2', 'width'], useFinalPosition);\n    const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      return inPointRange({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), width / 2, hitSize);\n    }\n    const limit = axis === 'y' ? {start: y, end: y2, value: mouseY} : {start: x, end: x2, value: mouseX};\n    return inLimit(limit, hitSize);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    const borderWidth = options.borderWidth;\n    if (options.radius < 0.1) {\n      return;\n    }\n    ctx.save();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    drawPoint(ctx, this, this.centerX, this.centerY);\n    if (stroke && !isImageOrCanvas(options.pointStyle)) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n    options.borderWidth = borderWidth;\n  }\n\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    properties.initProperties = initAnimationProperties(chart, properties, options);\n    return properties;\n  }\n}\n\nPointAnnotation.id = 'pointAnnotation';\n\nPointAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  hitTolerance: 0,\n  init: undefined,\n  pointStyle: 'circle',\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\n\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nclass PolygonAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    if (axis !== 'x' && axis !== 'y') {\n      return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\n    }\n    const rotatedPoint = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    const axisPoints = this.elements.map((point) => axis === 'y' ? point.bY : point.bX);\n    const start = Math.min(...axisPoints);\n    const end = Math.max(...axisPoints);\n    return rotatedPoint[axis] >= start && rotatedPoint[axis] <= end;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {elements, options} = this;\n    ctx.save();\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    let first = true;\n    for (const el of elements) {\n      if (first) {\n        ctx.moveTo(el.x, el.y);\n        first = false;\n      } else {\n        ctx.lineTo(el.x, el.y);\n      }\n    }\n    ctx.closePath();\n    ctx.fill();\n    // If no border, don't draw it\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    const {sides, rotation} = options;\n    const elements = [];\n    const angle = (2 * PI) / sides;\n    let rad = rotation * RAD_PER_DEG;\n    for (let i = 0; i < sides; i++, rad += angle) {\n      const elProps = buildPointElement(properties, options, rad);\n      elProps.initProperties = initAnimationProperties(chart, properties, options);\n      elements.push(elProps);\n    }\n    properties.elements = elements;\n    return properties;\n  }\n}\n\nPolygonAnnotation.id = 'polygonAnnotation';\n\nPolygonAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  hitTolerance: 0,\n  init: undefined,\n  point: {\n    radius: 0\n  },\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  sides: 3,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\n\nPolygonAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction buildPointElement({centerX, centerY}, {radius, borderWidth, hitTolerance}, rad) {\n  const hitSize = (borderWidth + hitTolerance) / 2;\n  const sin = Math.sin(rad);\n  const cos = Math.cos(rad);\n  const point = {x: centerX + sin * radius, y: centerY - cos * radius};\n  return {\n    type: 'point',\n    optionScope: 'point',\n    properties: {\n      x: point.x,\n      y: point.y,\n      centerX: point.x,\n      centerY: point.y,\n      bX: centerX + sin * (radius + hitSize),\n      bY: centerY - cos * (radius + hitSize)\n    }\n  };\n}\n\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\n  let isInside = false;\n  let A = points[points.length - 1].getProps(['bX', 'bY'], useFinalPosition);\n  for (const point of points) {\n    const B = point.getProps(['bX', 'bY'], useFinalPosition);\n    if ((B.bY > y) !== (A.bY > y) && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\n      isInside = !isInside;\n    }\n    A = B;\n  }\n  return isInside;\n}\n\nconst annotationTypes = {\n  box: BoxAnnotation,\n  doughnutLabel: DoughnutLabelAnnotation,\n  ellipse: EllipseAnnotation,\n  label: LabelAnnotation,\n  line: LineAnnotation,\n  point: PointAnnotation,\n  polygon: PolygonAnnotation\n};\n\n/**\n * Register fallback for annotation elements\n * For example lineAnnotation options would be looked through:\n * - the annotation object (options.plugins.annotation.annotations[id])\n * - element options (options.elements.lineAnnotation)\n * - element defaults (defaults.elements.lineAnnotation)\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\n */\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation.common'\n  });\n});\n\nconst directUpdater = {\n  update: Object.assign\n};\n\nconst hooks$1 = eventHooks.concat(elementHooks);\nconst resolve = (value, optDefs) => isObject(optDefs) ? resolveObj(value, optDefs) : value;\n\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").UpdateMode } UpdateMode\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */\n\n/**\n * @param {string} prop\n * @returns {boolean}\n */\nconst isIndexable = (prop) => prop === 'color' || prop === 'font';\n\n/**\n * Resolve the annotation type, checking if is supported.\n * @param {string} [type=line] - annotation type\n * @returns {string} resolved annotation type\n */\nfunction resolveType(type = 'line') {\n  if (annotationTypes[type]) {\n    return type;\n  }\n  console.warn(`Unknown annotation type: '${type}', defaulting to 'line'`);\n  return 'line';\n}\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n * @param {UpdateMode} mode\n */\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n\n  for (let i = 0; i < annotations.length; i++) {\n    const annotationOptions = annotations[i];\n    const element = getOrCreateElement(elements, i, annotationOptions.type);\n    const resolver = annotationOptions.setContext(getContext(chart, element, elements, annotationOptions));\n    const properties = element.resolveElementProperties(chart, resolver);\n\n    properties.skip = toSkip(properties);\n\n    if ('elements' in properties) {\n      updateSubElements(element, properties.elements, resolver, animations);\n      // Remove the sub-element definitions from properties, so the actual elements\n      // are not overwritten by their definitions\n      delete properties.elements;\n    }\n\n    if (!defined(element.x)) {\n      // If the element is newly created, assing the properties directly - to\n      // make them readily awailable to any scriptable options. If we do not do this,\n      // the properties retruned by `resolveElementProperties` are available only\n      // after options resolution.\n      Object.assign(element, properties);\n    }\n\n    Object.assign(element, properties.initProperties);\n    properties.options = resolveAnnotationOptions(resolver);\n\n    animations.update(element, properties);\n  }\n}\n\nfunction toSkip(properties) {\n  return isNaN(properties.x) || isNaN(properties.y);\n}\n\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\n\nfunction updateSubElements(mainElement, elements, resolver, animations) {\n  const subElements = mainElement.elements || (mainElement.elements = []);\n  subElements.length = elements.length;\n  for (let i = 0; i < elements.length; i++) {\n    const definition = elements[i];\n    const properties = definition.properties;\n    const subElement = getOrCreateElement(subElements, i, definition.type, definition.initProperties);\n    const subResolver = resolver[definition.optionScope].override(definition);\n    properties.options = resolveAnnotationOptions(subResolver);\n    animations.update(subElement, properties);\n  }\n}\n\nfunction getOrCreateElement(elements, index, type, initProperties) {\n  const elementClass = annotationTypes[resolveType(type)];\n  let element = elements[index];\n  if (!element || !(element instanceof elementClass)) {\n    element = elements[index] = new elementClass();\n    Object.assign(element, initProperties);\n  }\n  return element;\n}\n\nfunction resolveAnnotationOptions(resolver) {\n  const elementClass = annotationTypes[resolveType(resolver.type)];\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result,\n    resolveObj(resolver, elementClass.defaults),\n    resolveObj(resolver, elementClass.defaultRoutes));\n  for (const hook of hooks$1) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\n\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const prop of Object.keys(defs)) {\n    const optDefs = defs[prop];\n    const value = resolver[prop];\n    if (isIndexable(prop) && isArray(value)) {\n      result[prop] = value.map((item) => resolve(item, optDefs));\n    } else {\n      result[prop] = resolve(value, optDefs);\n    }\n  }\n  return result;\n}\n\nfunction getContext(chart, element, elements, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    get elements() {\n      return elements.filter((el) => el && el.options);\n    },\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\n\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\n\nvar version = \"3.1.0\";\n\nconst chartStates = new Map();\nconst isNotDoughnutLabel = annotation => annotation.type !== 'doughnutLabel';\nconst hooks = eventHooks.concat(elementHooks);\n\nvar annotation = {\n  id: 'annotation',\n\n  version,\n\n  beforeRegister() {\n    requireVersion('chart.js', '4.0', Chart.version);\n  },\n\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      visibleElements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false,\n      hooks: {},\n      hooked: false,\n      hovered: []\n    });\n  },\n\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n    verifyScaleOptions(annotations.filter(isNotDoughnutLabel), chart.scales);\n  },\n\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(isNotDoughnutLabel).filter(a => a.display && a.adjustScaleRange));\n  },\n\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n    state.visibleElements = state.elements.filter(el => !el.skip && el.options.display);\n    updateHooks(chart, state, options);\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options.clip);\n  },\n\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options.clip);\n  },\n\n  beforeDatasetDraw(chart, _args, options) {\n    draw(chart, _args.index, options.clip);\n  },\n\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options.clip);\n  },\n\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options.clip);\n  },\n\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    if (handleEvent(state, args.event, options)) {\n      args.changed = true;\n    }\n  },\n\n  afterDestroy(chart) {\n    chartStates.delete(chart);\n  },\n\n  getAnnotations(chart) {\n    const state = chartStates.get(chart);\n    return state ? state.elements : [];\n  },\n\n  // only for testing\n  _getAnnotationElementsAtEventForMode(visibleElements, event, options) {\n    return getElements(visibleElements, event, options);\n  },\n\n  defaults: {\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height', 'centerX', 'centerY', 'pointX', 'pointY', 'radius'],\n        type: 'number'\n      },\n      colors: {\n        properties: ['backgroundColor', 'borderColor'],\n        type: 'color'\n      }\n    },\n    clip: true,\n    interaction: {\n      mode: undefined,\n      axis: undefined,\n      intersect: undefined\n    },\n    common: {\n      drawTime: 'afterDatasetsDraw',\n      init: false,\n      label: {\n      }\n    }\n  },\n\n  descriptors: {\n    _indexable: false,\n    _scriptable: (prop) => !hooks.includes(prop) && prop !== 'init',\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[resolveType(opts.type)].id}`\n    },\n    interaction: {\n      _fallback: true\n    },\n    common: {\n      label: {\n        _indexable: isIndexable,\n        _fallback: true\n      },\n      _indexable: isIndexable\n    }\n  },\n\n  additionalOptionScopes: ['']\n};\n\nfunction draw(chart, caller, clip) {\n  const {ctx, chartArea} = chart;\n  const state = chartStates.get(chart);\n\n  if (clip) {\n    clipArea(ctx, chartArea);\n  }\n\n  const drawableElements = getDrawableElements(state.visibleElements, caller).sort((a, b) => a.element.options.z - b.element.options.z);\n  for (const item of drawableElements) {\n    drawElement(ctx, chartArea, state, item);\n  }\n\n  if (clip) {\n    unclipArea(ctx);\n  }\n}\n\nfunction getDrawableElements(elements, caller) {\n  const drawableElements = [];\n  for (const el of elements) {\n    if (el.options.drawTime === caller) {\n      drawableElements.push({element: el, main: true});\n    }\n    if (el.elements && el.elements.length) {\n      for (const sub of el.elements) {\n        if (sub.options.display && sub.options.drawTime === caller) {\n          drawableElements.push({element: sub});\n        }\n      }\n    }\n  }\n  return drawableElements;\n}\n\nfunction drawElement(ctx, chartArea, state, item) {\n  const el = item.element;\n  if (item.main) {\n    invokeHook(state, el, 'beforeDraw');\n    el.draw(ctx, chartArea);\n    invokeHook(state, el, 'afterDraw');\n  } else {\n    el.draw(ctx, chartArea);\n  }\n}\n\nexport { annotation as default };\n","/*!\n * chartjs-plugin-datalabels v2.2.0\n * https://chartjs-plugin-datalabels.netlify.app\n * (c) 2017-2022 chartjs-plugin-datalabels contributors\n * Released under the MIT license\n */\nimport { isNullOrUndef, merge, toFont, resolve, toPadding, valueOrDefault, callback, isObject, each } from 'chart.js/helpers';\nimport { defaults as defaults$1, ArcElement, PointElement, BarElement } from 'chart.js';\n\nvar devicePixelRatio = (function() {\n  if (typeof window !== 'undefined') {\n    if (window.devicePixelRatio) {\n      return window.devicePixelRatio;\n    }\n\n    // devicePixelRatio is undefined on IE10\n    // https://stackoverflow.com/a/20204180/8837887\n    // https://github.com/chartjs/chartjs-plugin-datalabels/issues/85\n    var screen = window.screen;\n    if (screen) {\n      return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);\n    }\n  }\n\n  return 1;\n}());\n\nvar utils = {\n  // @todo move this in Chart.helpers.toTextLines\n  toTextLines: function(inputs) {\n    var lines = [];\n    var input;\n\n    inputs = [].concat(inputs);\n    while (inputs.length) {\n      input = inputs.pop();\n      if (typeof input === 'string') {\n        lines.unshift.apply(lines, input.split('\\n'));\n      } else if (Array.isArray(input)) {\n        inputs.push.apply(inputs, input);\n      } else if (!isNullOrUndef(inputs)) {\n        lines.unshift('' + input);\n      }\n    }\n\n    return lines;\n  },\n\n  // @todo move this in Chart.helpers.canvas.textSize\n  // @todo cache calls of measureText if font doesn't change?!\n  textSize: function(ctx, lines, font) {\n    var items = [].concat(lines);\n    var ilen = items.length;\n    var prev = ctx.font;\n    var width = 0;\n    var i;\n\n    ctx.font = font.string;\n\n    for (i = 0; i < ilen; ++i) {\n      width = Math.max(ctx.measureText(items[i]).width, width);\n    }\n\n    ctx.font = prev;\n\n    return {\n      height: ilen * font.lineHeight,\n      width: width\n    };\n  },\n\n  /**\n   * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).\n   * @todo move this method in Chart.helpers.bound\n   * https://doc.qt.io/qt-5/qtglobal.html#qBound\n   */\n  bound: function(min, value, max) {\n    return Math.max(min, Math.min(value, max));\n  },\n\n  /**\n   * Returns an array of pair [value, state] where state is:\n   * * -1: value is only in a0 (removed)\n   * *  1: value is only in a1 (added)\n   */\n  arrayDiff: function(a0, a1) {\n    var prev = a0.slice();\n    var updates = [];\n    var i, j, ilen, v;\n\n    for (i = 0, ilen = a1.length; i < ilen; ++i) {\n      v = a1[i];\n      j = prev.indexOf(v);\n\n      if (j === -1) {\n        updates.push([v, 1]);\n      } else {\n        prev.splice(j, 1);\n      }\n    }\n\n    for (i = 0, ilen = prev.length; i < ilen; ++i) {\n      updates.push([prev[i], -1]);\n    }\n\n    return updates;\n  },\n\n  /**\n   * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70\n   */\n  rasterize: function(v) {\n    return Math.round(v * devicePixelRatio) / devicePixelRatio;\n  }\n};\n\nfunction orient(point, origin) {\n  var x0 = origin.x;\n  var y0 = origin.y;\n\n  if (x0 === null) {\n    return {x: 0, y: -1};\n  }\n  if (y0 === null) {\n    return {x: 1, y: 0};\n  }\n\n  var dx = point.x - x0;\n  var dy = point.y - y0;\n  var ln = Math.sqrt(dx * dx + dy * dy);\n\n  return {\n    x: ln ? dx / ln : 0,\n    y: ln ? dy / ln : -1\n  };\n}\n\nfunction aligned(x, y, vx, vy, align) {\n  switch (align) {\n  case 'center':\n    vx = vy = 0;\n    break;\n  case 'bottom':\n    vx = 0;\n    vy = 1;\n    break;\n  case 'right':\n    vx = 1;\n    vy = 0;\n    break;\n  case 'left':\n    vx = -1;\n    vy = 0;\n    break;\n  case 'top':\n    vx = 0;\n    vy = -1;\n    break;\n  case 'start':\n    vx = -vx;\n    vy = -vy;\n    break;\n  case 'end':\n    // keep natural orientation\n    break;\n  default:\n    // clockwise rotation (in degree)\n    align *= (Math.PI / 180);\n    vx = Math.cos(align);\n    vy = Math.sin(align);\n    break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    vx: vx,\n    vy: vy\n  };\n}\n\n// Line clipping (Cohen–Sutherland algorithm)\n// https://en.wikipedia.org/wiki/Cohen–Sutherland_algorithm\n\nvar R_INSIDE = 0;\nvar R_LEFT = 1;\nvar R_RIGHT = 2;\nvar R_BOTTOM = 4;\nvar R_TOP = 8;\n\nfunction region(x, y, rect) {\n  var res = R_INSIDE;\n\n  if (x < rect.left) {\n    res |= R_LEFT;\n  } else if (x > rect.right) {\n    res |= R_RIGHT;\n  }\n  if (y < rect.top) {\n    res |= R_TOP;\n  } else if (y > rect.bottom) {\n    res |= R_BOTTOM;\n  }\n\n  return res;\n}\n\nfunction clipped(segment, area) {\n  var x0 = segment.x0;\n  var y0 = segment.y0;\n  var x1 = segment.x1;\n  var y1 = segment.y1;\n  var r0 = region(x0, y0, area);\n  var r1 = region(x1, y1, area);\n  var r, x, y;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (!(r0 | r1) || (r0 & r1)) {\n      // both points inside or on the same side: no clipping\n      break;\n    }\n\n    // at least one point is outside\n    r = r0 || r1;\n\n    if (r & R_TOP) {\n      x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);\n      y = area.top;\n    } else if (r & R_BOTTOM) {\n      x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);\n      y = area.bottom;\n    } else if (r & R_RIGHT) {\n      y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);\n      x = area.right;\n    } else if (r & R_LEFT) {\n      y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);\n      x = area.left;\n    }\n\n    if (r === r0) {\n      x0 = x;\n      y0 = y;\n      r0 = region(x0, y0, area);\n    } else {\n      x1 = x;\n      y1 = y;\n      r1 = region(x1, y1, area);\n    }\n  }\n\n  return {\n    x0: x0,\n    x1: x1,\n    y0: y0,\n    y1: y1\n  };\n}\n\nfunction compute$1(range, config) {\n  var anchor = config.anchor;\n  var segment = range;\n  var x, y;\n\n  if (config.clamp) {\n    segment = clipped(segment, config.area);\n  }\n\n  if (anchor === 'start') {\n    x = segment.x0;\n    y = segment.y0;\n  } else if (anchor === 'end') {\n    x = segment.x1;\n    y = segment.y1;\n  } else {\n    x = (segment.x0 + segment.x1) / 2;\n    y = (segment.y0 + segment.y1) / 2;\n  }\n\n  return aligned(x, y, range.vx, range.vy, config.align);\n}\n\nvar positioners = {\n  arc: function(el, config) {\n    var angle = (el.startAngle + el.endAngle) / 2;\n    var vx = Math.cos(angle);\n    var vy = Math.sin(angle);\n    var r0 = el.innerRadius;\n    var r1 = el.outerRadius;\n\n    return compute$1({\n      x0: el.x + vx * r0,\n      y0: el.y + vy * r0,\n      x1: el.x + vx * r1,\n      y1: el.y + vy * r1,\n      vx: vx,\n      vy: vy\n    }, config);\n  },\n\n  point: function(el, config) {\n    var v = orient(el, config.origin);\n    var rx = v.x * el.options.radius;\n    var ry = v.y * el.options.radius;\n\n    return compute$1({\n      x0: el.x - rx,\n      y0: el.y - ry,\n      x1: el.x + rx,\n      y1: el.y + ry,\n      vx: v.x,\n      vy: v.y\n    }, config);\n  },\n\n  bar: function(el, config) {\n    var v = orient(el, config.origin);\n    var x = el.x;\n    var y = el.y;\n    var sx = 0;\n    var sy = 0;\n\n    if (el.horizontal) {\n      x = Math.min(el.x, el.base);\n      sx = Math.abs(el.base - el.x);\n    } else {\n      y = Math.min(el.y, el.base);\n      sy = Math.abs(el.base - el.y);\n    }\n\n    return compute$1({\n      x0: x,\n      y0: y + sy,\n      x1: x + sx,\n      y1: y,\n      vx: v.x,\n      vy: v.y\n    }, config);\n  },\n\n  fallback: function(el, config) {\n    var v = orient(el, config.origin);\n\n    return compute$1({\n      x0: el.x,\n      y0: el.y,\n      x1: el.x + (el.width || 0),\n      y1: el.y + (el.height || 0),\n      vx: v.x,\n      vy: v.y\n    }, config);\n  }\n};\n\nvar rasterize = utils.rasterize;\n\nfunction boundingRects(model) {\n  var borderWidth = model.borderWidth || 0;\n  var padding = model.padding;\n  var th = model.size.height;\n  var tw = model.size.width;\n  var tx = -tw / 2;\n  var ty = -th / 2;\n\n  return {\n    frame: {\n      x: tx - padding.left - borderWidth,\n      y: ty - padding.top - borderWidth,\n      w: tw + padding.width + borderWidth * 2,\n      h: th + padding.height + borderWidth * 2\n    },\n    text: {\n      x: tx,\n      y: ty,\n      w: tw,\n      h: th\n    }\n  };\n}\n\nfunction getScaleOrigin(el, context) {\n  var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;\n\n  if (!scale) {\n    return null;\n  }\n\n  if (scale.xCenter !== undefined && scale.yCenter !== undefined) {\n    return {x: scale.xCenter, y: scale.yCenter};\n  }\n\n  var pixel = scale.getBasePixel();\n  return el.horizontal ?\n    {x: pixel, y: null} :\n    {x: null, y: pixel};\n}\n\nfunction getPositioner(el) {\n  if (el instanceof ArcElement) {\n    return positioners.arc;\n  }\n  if (el instanceof PointElement) {\n    return positioners.point;\n  }\n  if (el instanceof BarElement) {\n    return positioners.bar;\n  }\n  return positioners.fallback;\n}\n\nfunction drawRoundedRect(ctx, x, y, w, h, radius) {\n  var HALF_PI = Math.PI / 2;\n\n  if (radius) {\n    var r = Math.min(radius, h / 2, w / 2);\n    var left = x + r;\n    var top = y + r;\n    var right = x + w - r;\n    var bottom = y + h - r;\n\n    ctx.moveTo(x, top);\n    if (left < right && top < bottom) {\n      ctx.arc(left, top, r, -Math.PI, -HALF_PI);\n      ctx.arc(right, top, r, -HALF_PI, 0);\n      ctx.arc(right, bottom, r, 0, HALF_PI);\n      ctx.arc(left, bottom, r, HALF_PI, Math.PI);\n    } else if (left < right) {\n      ctx.moveTo(left, y);\n      ctx.arc(right, top, r, -HALF_PI, HALF_PI);\n      ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);\n    } else if (top < bottom) {\n      ctx.arc(left, top, r, -Math.PI, 0);\n      ctx.arc(left, bottom, r, 0, Math.PI);\n    } else {\n      ctx.arc(left, top, r, -Math.PI, Math.PI);\n    }\n    ctx.closePath();\n    ctx.moveTo(x, y);\n  } else {\n    ctx.rect(x, y, w, h);\n  }\n}\n\nfunction drawFrame(ctx, rect, model) {\n  var bgColor = model.backgroundColor;\n  var borderColor = model.borderColor;\n  var borderWidth = model.borderWidth;\n\n  if (!bgColor && (!borderColor || !borderWidth)) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  drawRoundedRect(\n    ctx,\n    rasterize(rect.x) + borderWidth / 2,\n    rasterize(rect.y) + borderWidth / 2,\n    rasterize(rect.w) - borderWidth,\n    rasterize(rect.h) - borderWidth,\n    model.borderRadius);\n\n  ctx.closePath();\n\n  if (bgColor) {\n    ctx.fillStyle = bgColor;\n    ctx.fill();\n  }\n\n  if (borderColor && borderWidth) {\n    ctx.strokeStyle = borderColor;\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = 'miter';\n    ctx.stroke();\n  }\n}\n\nfunction textGeometry(rect, align, font) {\n  var h = font.lineHeight;\n  var w = rect.w;\n  var x = rect.x;\n  var y = rect.y + h / 2;\n\n  if (align === 'center') {\n    x += w / 2;\n  } else if (align === 'end' || align === 'right') {\n    x += w;\n  }\n\n  return {\n    h: h,\n    w: w,\n    x: x,\n    y: y\n  };\n}\n\nfunction drawTextLine(ctx, text, cfg) {\n  var shadow = ctx.shadowBlur;\n  var stroked = cfg.stroked;\n  var x = rasterize(cfg.x);\n  var y = rasterize(cfg.y);\n  var w = rasterize(cfg.w);\n\n  if (stroked) {\n    ctx.strokeText(text, x, y, w);\n  }\n\n  if (cfg.filled) {\n    if (shadow && stroked) {\n      // Prevent drawing shadow on both the text stroke and fill, so\n      // if the text is stroked, remove the shadow for the text fill.\n      ctx.shadowBlur = 0;\n    }\n\n    ctx.fillText(text, x, y, w);\n\n    if (shadow && stroked) {\n      ctx.shadowBlur = shadow;\n    }\n  }\n}\n\nfunction drawText(ctx, lines, rect, model) {\n  var align = model.textAlign;\n  var color = model.color;\n  var filled = !!color;\n  var font = model.font;\n  var ilen = lines.length;\n  var strokeColor = model.textStrokeColor;\n  var strokeWidth = model.textStrokeWidth;\n  var stroked = strokeColor && strokeWidth;\n  var i;\n\n  if (!ilen || (!filled && !stroked)) {\n    return;\n  }\n\n  // Adjust coordinates based on text alignment and line height\n  rect = textGeometry(rect, align, font);\n\n  ctx.font = font.string;\n  ctx.textAlign = align;\n  ctx.textBaseline = 'middle';\n  ctx.shadowBlur = model.textShadowBlur;\n  ctx.shadowColor = model.textShadowColor;\n\n  if (filled) {\n    ctx.fillStyle = color;\n  }\n  if (stroked) {\n    ctx.lineJoin = 'round';\n    ctx.lineWidth = strokeWidth;\n    ctx.strokeStyle = strokeColor;\n  }\n\n  for (i = 0, ilen = lines.length; i < ilen; ++i) {\n    drawTextLine(ctx, lines[i], {\n      stroked: stroked,\n      filled: filled,\n      w: rect.w,\n      x: rect.x,\n      y: rect.y + rect.h * i\n    });\n  }\n}\n\nvar Label = function(config, ctx, el, index) {\n  var me = this;\n\n  me._config = config;\n  me._index = index;\n  me._model = null;\n  me._rects = null;\n  me._ctx = ctx;\n  me._el = el;\n};\n\nmerge(Label.prototype, {\n  /**\n   * @private\n   */\n  _modelize: function(display, lines, config, context) {\n    var me = this;\n    var index = me._index;\n    var font = toFont(resolve([config.font, {}], context, index));\n    var color = resolve([config.color, defaults$1.color], context, index);\n\n    return {\n      align: resolve([config.align, 'center'], context, index),\n      anchor: resolve([config.anchor, 'center'], context, index),\n      area: context.chart.chartArea,\n      backgroundColor: resolve([config.backgroundColor, null], context, index),\n      borderColor: resolve([config.borderColor, null], context, index),\n      borderRadius: resolve([config.borderRadius, 0], context, index),\n      borderWidth: resolve([config.borderWidth, 0], context, index),\n      clamp: resolve([config.clamp, false], context, index),\n      clip: resolve([config.clip, false], context, index),\n      color: color,\n      display: display,\n      font: font,\n      lines: lines,\n      offset: resolve([config.offset, 4], context, index),\n      opacity: resolve([config.opacity, 1], context, index),\n      origin: getScaleOrigin(me._el, context),\n      padding: toPadding(resolve([config.padding, 4], context, index)),\n      positioner: getPositioner(me._el),\n      rotation: resolve([config.rotation, 0], context, index) * (Math.PI / 180),\n      size: utils.textSize(me._ctx, lines, font),\n      textAlign: resolve([config.textAlign, 'start'], context, index),\n      textShadowBlur: resolve([config.textShadowBlur, 0], context, index),\n      textShadowColor: resolve([config.textShadowColor, color], context, index),\n      textStrokeColor: resolve([config.textStrokeColor, color], context, index),\n      textStrokeWidth: resolve([config.textStrokeWidth, 0], context, index)\n    };\n  },\n\n  update: function(context) {\n    var me = this;\n    var model = null;\n    var rects = null;\n    var index = me._index;\n    var config = me._config;\n    var value, label, lines;\n\n    // We first resolve the display option (separately) to avoid computing\n    // other options in case the label is hidden (i.e. display: false).\n    var display = resolve([config.display, true], context, index);\n\n    if (display) {\n      value = context.dataset.data[index];\n      label = valueOrDefault(callback(config.formatter, [value, context]), value);\n      lines = isNullOrUndef(label) ? [] : utils.toTextLines(label);\n\n      if (lines.length) {\n        model = me._modelize(display, lines, config, context);\n        rects = boundingRects(model);\n      }\n    }\n\n    me._model = model;\n    me._rects = rects;\n  },\n\n  geometry: function() {\n    return this._rects ? this._rects.frame : {};\n  },\n\n  rotation: function() {\n    return this._model ? this._model.rotation : 0;\n  },\n\n  visible: function() {\n    return this._model && this._model.opacity;\n  },\n\n  model: function() {\n    return this._model;\n  },\n\n  draw: function(chart, center) {\n    var me = this;\n    var ctx = chart.ctx;\n    var model = me._model;\n    var rects = me._rects;\n    var area;\n\n    if (!this.visible()) {\n      return;\n    }\n\n    ctx.save();\n\n    if (model.clip) {\n      area = model.area;\n      ctx.beginPath();\n      ctx.rect(\n        area.left,\n        area.top,\n        area.right - area.left,\n        area.bottom - area.top);\n      ctx.clip();\n    }\n\n    ctx.globalAlpha = utils.bound(0, model.opacity, 1);\n    ctx.translate(rasterize(center.x), rasterize(center.y));\n    ctx.rotate(model.rotation);\n\n    drawFrame(ctx, rects.frame, model);\n    drawText(ctx, model.lines, rects.text, model);\n\n    ctx.restore();\n  }\n});\n\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991; // eslint-disable-line es/no-number-minsafeinteger\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;  // eslint-disable-line es/no-number-maxsafeinteger\n\nfunction rotated(point, center, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var cx = center.x;\n  var cy = center.y;\n\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\nfunction projected(points, axis) {\n  var min = MAX_INTEGER;\n  var max = MIN_INTEGER;\n  var origin = axis.origin;\n  var i, pt, vx, vy, dp;\n\n  for (i = 0; i < points.length; ++i) {\n    pt = points[i];\n    vx = pt.x - origin.x;\n    vy = pt.y - origin.y;\n    dp = axis.vx * vx + axis.vy * vy;\n    min = Math.min(min, dp);\n    max = Math.max(max, dp);\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n\nfunction toAxis(p0, p1) {\n  var vx = p1.x - p0.x;\n  var vy = p1.y - p0.y;\n  var ln = Math.sqrt(vx * vx + vy * vy);\n\n  return {\n    vx: (p1.x - p0.x) / ln,\n    vy: (p1.y - p0.y) / ln,\n    origin: p0,\n    ln: ln\n  };\n}\n\nvar HitBox = function() {\n  this._rotation = 0;\n  this._rect = {\n    x: 0,\n    y: 0,\n    w: 0,\n    h: 0\n  };\n};\n\nmerge(HitBox.prototype, {\n  center: function() {\n    var r = this._rect;\n    return {\n      x: r.x + r.w / 2,\n      y: r.y + r.h / 2\n    };\n  },\n\n  update: function(center, rect, rotation) {\n    this._rotation = rotation;\n    this._rect = {\n      x: rect.x + center.x,\n      y: rect.y + center.y,\n      w: rect.w,\n      h: rect.h\n    };\n  },\n\n  contains: function(point) {\n    var me = this;\n    var margin = 1;\n    var rect = me._rect;\n\n    point = rotated(point, me.center(), -me._rotation);\n\n    return !(point.x < rect.x - margin\n      || point.y < rect.y - margin\n      || point.x > rect.x + rect.w + margin * 2\n      || point.y > rect.y + rect.h + margin * 2);\n  },\n\n  // Separating Axis Theorem\n  // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\n  intersects: function(other) {\n    var r0 = this._points();\n    var r1 = other._points();\n    var axes = [\n      toAxis(r0[0], r0[1]),\n      toAxis(r0[0], r0[3])\n    ];\n    var i, pr0, pr1;\n\n    if (this._rotation !== other._rotation) {\n      // Only separate with r1 axis if the rotation is different,\n      // else it's enough to separate r0 and r1 with r0 axis only!\n      axes.push(\n        toAxis(r1[0], r1[1]),\n        toAxis(r1[0], r1[3])\n      );\n    }\n\n    for (i = 0; i < axes.length; ++i) {\n      pr0 = projected(r0, axes[i]);\n      pr1 = projected(r1, axes[i]);\n\n      if (pr0.max < pr1.min || pr1.max < pr0.min) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * @private\n   */\n  _points: function() {\n    var me = this;\n    var rect = me._rect;\n    var angle = me._rotation;\n    var center = me.center();\n\n    return [\n      rotated({x: rect.x, y: rect.y}, center, angle),\n      rotated({x: rect.x + rect.w, y: rect.y}, center, angle),\n      rotated({x: rect.x + rect.w, y: rect.y + rect.h}, center, angle),\n      rotated({x: rect.x, y: rect.y + rect.h}, center, angle)\n    ];\n  }\n});\n\nfunction coordinates(el, model, geometry) {\n  var point = model.positioner(el, model);\n  var vx = point.vx;\n  var vy = point.vy;\n\n  if (!vx && !vy) {\n    // if aligned center, we don't want to offset the center point\n    return {x: point.x, y: point.y};\n  }\n\n  var w = geometry.w;\n  var h = geometry.h;\n\n  // take in account the label rotation\n  var rotation = model.rotation;\n  var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));\n  var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));\n\n  // scale the unit vector (vx, vy) to get at least dx or dy equal to\n  // w or h respectively (else we would calculate the distance to the\n  // ellipse inscribed in the bounding rect)\n  var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));\n  dx *= vx * vs;\n  dy *= vy * vs;\n\n  // finally, include the explicit offset\n  dx += model.offset * vx;\n  dy += model.offset * vy;\n\n  return {\n    x: point.x + dx,\n    y: point.y + dy\n  };\n}\n\nfunction collide(labels, collider) {\n  var i, j, s0, s1;\n\n  // IMPORTANT Iterate in the reverse order since items at the end of the\n  // list have an higher weight/priority and thus should be less impacted\n  // by the overlapping strategy.\n\n  for (i = labels.length - 1; i >= 0; --i) {\n    s0 = labels[i].$layout;\n\n    for (j = i - 1; j >= 0 && s0._visible; --j) {\n      s1 = labels[j].$layout;\n\n      if (s1._visible && s0._box.intersects(s1._box)) {\n        collider(s0, s1);\n      }\n    }\n  }\n\n  return labels;\n}\n\nfunction compute(labels) {\n  var i, ilen, label, state, geometry, center, proxy;\n\n  // Initialize labels for overlap detection\n  for (i = 0, ilen = labels.length; i < ilen; ++i) {\n    label = labels[i];\n    state = label.$layout;\n\n    if (state._visible) {\n      // Chart.js 3 removed el._model in favor of getProps(), making harder to\n      // abstract reading values in positioners. Also, using string arrays to\n      // read values (i.e. var {a,b,c} = el.getProps([\"a\",\"b\",\"c\"])) would make\n      // positioners inefficient in the normal case (i.e. not the final values)\n      // and the code a bit ugly, so let's use a Proxy instead.\n      proxy = new Proxy(label._el, {get: (el, p) => el.getProps([p], true)[p]});\n\n      geometry = label.geometry();\n      center = coordinates(proxy, label.model(), geometry);\n      state._box.update(center, geometry, label.rotation());\n    }\n  }\n\n  // Auto hide overlapping labels\n  return collide(labels, function(s0, s1) {\n    var h0 = s0._hidable;\n    var h1 = s1._hidable;\n\n    if ((h0 && h1) || h1) {\n      s1._visible = false;\n    } else if (h0) {\n      s0._visible = false;\n    }\n  });\n}\n\nvar layout = {\n  prepare: function(datasets) {\n    var labels = [];\n    var i, j, ilen, jlen, label;\n\n    for (i = 0, ilen = datasets.length; i < ilen; ++i) {\n      for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {\n        label = datasets[i][j];\n        labels.push(label);\n        label.$layout = {\n          _box: new HitBox(),\n          _hidable: false,\n          _visible: true,\n          _set: i,\n          _idx: label._index\n        };\n      }\n    }\n\n    // TODO New `z` option: labels with a higher z-index are drawn\n    // of top of the ones with a lower index. Lowest z-index labels\n    // are also discarded first when hiding overlapping labels.\n    labels.sort(function(a, b) {\n      var sa = a.$layout;\n      var sb = b.$layout;\n\n      return sa._idx === sb._idx\n        ? sb._set - sa._set\n        : sb._idx - sa._idx;\n    });\n\n    this.update(labels);\n\n    return labels;\n  },\n\n  update: function(labels) {\n    var dirty = false;\n    var i, ilen, label, model, state;\n\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      label = labels[i];\n      model = label.model();\n      state = label.$layout;\n      state._hidable = model && model.display === 'auto';\n      state._visible = label.visible();\n      dirty |= state._hidable;\n    }\n\n    if (dirty) {\n      compute(labels);\n    }\n  },\n\n  lookup: function(labels, point) {\n    var i, state;\n\n    // IMPORTANT Iterate in the reverse order since items at the end of\n    // the list have an higher z-index, thus should be picked first.\n\n    for (i = labels.length - 1; i >= 0; --i) {\n      state = labels[i].$layout;\n\n      if (state && state._visible && state._box.contains(point)) {\n        return labels[i];\n      }\n    }\n\n    return null;\n  },\n\n  draw: function(chart, labels) {\n    var i, ilen, label, state, geometry, center;\n\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      label = labels[i];\n      state = label.$layout;\n\n      if (state._visible) {\n        geometry = label.geometry();\n        center = coordinates(label._el, label.model(), geometry);\n        state._box.update(center, geometry, label.rotation());\n        label.draw(chart, center);\n      }\n    }\n  }\n};\n\nvar formatter = function(value) {\n  if (isNullOrUndef(value)) {\n    return null;\n  }\n\n  var label = value;\n  var keys, klen, k;\n  if (isObject(value)) {\n    if (!isNullOrUndef(value.label)) {\n      label = value.label;\n    } else if (!isNullOrUndef(value.r)) {\n      label = value.r;\n    } else {\n      label = '';\n      keys = Object.keys(value);\n      for (k = 0, klen = keys.length; k < klen; ++k) {\n        label += (k !== 0 ? ', ' : '') + keys[k] + ': ' + value[keys[k]];\n      }\n    }\n  }\n\n  return '' + label;\n};\n\n/**\n * IMPORTANT: make sure to also update tests and TypeScript definition\n * files (`/test/specs/defaults.spec.js` and `/types/options.d.ts`)\n */\n\nvar defaults = {\n  align: 'center',\n  anchor: 'center',\n  backgroundColor: null,\n  borderColor: null,\n  borderRadius: 0,\n  borderWidth: 0,\n  clamp: false,\n  clip: false,\n  color: undefined,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: 1.2,\n    size: undefined,\n    style: undefined,\n    weight: null\n  },\n  formatter: formatter,\n  labels: undefined,\n  listeners: {},\n  offset: 4,\n  opacity: 1,\n  padding: {\n    top: 4,\n    right: 4,\n    bottom: 4,\n    left: 4\n  },\n  rotation: 0,\n  textAlign: 'start',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  textShadowBlur: 0,\n  textShadowColor: undefined\n};\n\n/**\n * @see https://github.com/chartjs/Chart.js/issues/4176\n */\n\nvar EXPANDO_KEY = '$datalabels';\nvar DEFAULT_KEY = '$default';\n\nfunction configure(dataset, options) {\n  var override = dataset.datalabels;\n  var listeners = {};\n  var configs = [];\n  var labels, keys;\n\n  if (override === false) {\n    return null;\n  }\n  if (override === true) {\n    override = {};\n  }\n\n  options = merge({}, [options, override]);\n  labels = options.labels || {};\n  keys = Object.keys(labels);\n  delete options.labels;\n\n  if (keys.length) {\n    keys.forEach(function(key) {\n      if (labels[key]) {\n        configs.push(merge({}, [\n          options,\n          labels[key],\n          {_key: key}\n        ]));\n      }\n    });\n  } else {\n    // Default label if no \"named\" label defined.\n    configs.push(options);\n  }\n\n  // listeners: {<event-type>: {<label-key>: <fn>}}\n  listeners = configs.reduce(function(target, config) {\n    each(config.listeners || {}, function(fn, event) {\n      target[event] = target[event] || {};\n      target[event][config._key || DEFAULT_KEY] = fn;\n    });\n\n    delete config.listeners;\n    return target;\n  }, {});\n\n  return {\n    labels: configs,\n    listeners: listeners\n  };\n}\n\nfunction dispatchEvent(chart, listeners, label, event) {\n  if (!listeners) {\n    return;\n  }\n\n  var context = label.$context;\n  var groups = label.$groups;\n  var callback$1;\n\n  if (!listeners[groups._set]) {\n    return;\n  }\n\n  callback$1 = listeners[groups._set][groups._key];\n  if (!callback$1) {\n    return;\n  }\n\n  if (callback(callback$1, [context, event]) === true) {\n    // Users are allowed to tweak the given context by injecting values that can be\n    // used in scriptable options to display labels differently based on the current\n    // event (e.g. highlight an hovered label). That's why we update the label with\n    // the output context and schedule a new chart render by setting it dirty.\n    chart[EXPANDO_KEY]._dirty = true;\n    label.update(context);\n  }\n}\n\nfunction dispatchMoveEvents(chart, listeners, previous, label, event) {\n  var enter, leave;\n\n  if (!previous && !label) {\n    return;\n  }\n\n  if (!previous) {\n    enter = true;\n  } else if (!label) {\n    leave = true;\n  } else if (previous !== label) {\n    leave = enter = true;\n  }\n\n  if (leave) {\n    dispatchEvent(chart, listeners.leave, previous, event);\n  }\n  if (enter) {\n    dispatchEvent(chart, listeners.enter, label, event);\n  }\n}\n\nfunction handleMoveEvents(chart, event) {\n  var expando = chart[EXPANDO_KEY];\n  var listeners = expando._listeners;\n  var previous, label;\n\n  if (!listeners.enter && !listeners.leave) {\n    return;\n  }\n\n  if (event.type === 'mousemove') {\n    label = layout.lookup(expando._labels, event);\n  } else if (event.type !== 'mouseout') {\n    return;\n  }\n\n  previous = expando._hovered;\n  expando._hovered = label;\n  dispatchMoveEvents(chart, listeners, previous, label, event);\n}\n\nfunction handleClickEvents(chart, event) {\n  var expando = chart[EXPANDO_KEY];\n  var handlers = expando._listeners.click;\n  var label = handlers && layout.lookup(expando._labels, event);\n  if (label) {\n    dispatchEvent(chart, handlers, label, event);\n  }\n}\n\nvar plugin = {\n  id: 'datalabels',\n\n  defaults: defaults,\n\n  beforeInit: function(chart) {\n    chart[EXPANDO_KEY] = {\n      _actives: []\n    };\n  },\n\n  beforeUpdate: function(chart) {\n    var expando = chart[EXPANDO_KEY];\n    expando._listened = false;\n    expando._listeners = {};     // {<event-type>: {<dataset-index>: {<label-key>: <fn>}}}\n    expando._datasets = [];      // per dataset labels: [Label[]]\n    expando._labels = [];        // layouted labels: Label[]\n  },\n\n  afterDatasetUpdate: function(chart, args, options) {\n    var datasetIndex = args.index;\n    var expando = chart[EXPANDO_KEY];\n    var labels = expando._datasets[datasetIndex] = [];\n    var visible = chart.isDatasetVisible(datasetIndex);\n    var dataset = chart.data.datasets[datasetIndex];\n    var config = configure(dataset, options);\n    var elements = args.meta.data || [];\n    var ctx = chart.ctx;\n    var i, j, ilen, jlen, cfg, key, el, label;\n\n    ctx.save();\n\n    for (i = 0, ilen = elements.length; i < ilen; ++i) {\n      el = elements[i];\n      el[EXPANDO_KEY] = [];\n\n      if (visible && el && chart.getDataVisibility(i) && !el.skip) {\n        for (j = 0, jlen = config.labels.length; j < jlen; ++j) {\n          cfg = config.labels[j];\n          key = cfg._key;\n\n          label = new Label(cfg, ctx, el, i);\n          label.$groups = {\n            _set: datasetIndex,\n            _key: key || DEFAULT_KEY\n          };\n          label.$context = {\n            active: false,\n            chart: chart,\n            dataIndex: i,\n            dataset: dataset,\n            datasetIndex: datasetIndex\n          };\n\n          label.update(label.$context);\n          el[EXPANDO_KEY].push(label);\n          labels.push(label);\n        }\n      }\n    }\n\n    ctx.restore();\n\n    // Store listeners at the chart level and per event type to optimize\n    // cases where no listeners are registered for a specific event.\n    merge(expando._listeners, config.listeners, {\n      merger: function(event, target, source) {\n        target[event] = target[event] || {};\n        target[event][args.index] = source[event];\n        expando._listened = true;\n      }\n    });\n  },\n\n  afterUpdate: function(chart) {\n    chart[EXPANDO_KEY]._labels = layout.prepare(chart[EXPANDO_KEY]._datasets);\n  },\n\n  // Draw labels on top of all dataset elements\n  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29\n  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32\n  afterDatasetsDraw: function(chart) {\n    layout.draw(chart, chart[EXPANDO_KEY]._labels);\n  },\n\n  beforeEvent: function(chart, args) {\n    // If there is no listener registered for this chart, `listened` will be false,\n    // meaning we can immediately ignore the incoming event and avoid useless extra\n    // computation for users who don't implement label interactions.\n    if (chart[EXPANDO_KEY]._listened) {\n      var event = args.event;\n      switch (event.type) {\n      case 'mousemove':\n      case 'mouseout':\n        handleMoveEvents(chart, event);\n        break;\n      case 'click':\n        handleClickEvents(chart, event);\n        break;\n      }\n    }\n  },\n\n  afterEvent: function(chart) {\n    var expando = chart[EXPANDO_KEY];\n    var previous = expando._actives;\n    var actives = expando._actives = chart.getActiveElements();\n    var updates = utils.arrayDiff(previous, actives);\n    var i, ilen, j, jlen, update, label, labels;\n\n    for (i = 0, ilen = updates.length; i < ilen; ++i) {\n      update = updates[i];\n      if (update[1]) {\n        labels = update[0].element[EXPANDO_KEY] || [];\n        for (j = 0, jlen = labels.length; j < jlen; ++j) {\n          label = labels[j];\n          label.$context.active = (update[1] === 1);\n          label.update(label.$context);\n        }\n      }\n    }\n\n    if (expando._dirty || updates.length) {\n      layout.update(expando._labels);\n      chart.render();\n    }\n\n    delete expando._dirty;\n  }\n};\n\nexport { plugin as default };\n"],"sourceRoot":""}